#include <Arduino.h>
#include <ESP8266WiFi.h>
#include <ESP8266WebServer.h>
#include <LittleFS.h>      
#include <ArduinoJson.h>   
#include <ESP.h>           
#include "secrets.h"       
#include <Ticker.h>             
#include <memory>
#include <vector>
#include <stdarg.h> 
#include <algorithm> 
#include <cmath> 
#include <ArduinoOTA.h>    
#include <ESP8266mDNS.h>   

extern "C" {
  #include "user_interface.h"
}

#pragma GCC optimize ("O3")

// =========================================================
// 1. GLOBALE DEFS UND LOGGER
// =========================================================

// --- GLOBALE LOG-LEVELS ---
enum LogLevel { LOG_DEBUG, LOG_INFO, LOG_WARN, LOG_ERROR };
// Forward Deklaration des Loggers
void app_log(LogLevel level, const char* file, int line, int logLine, const char* format, ...);
// Das Makro verwendet die Zeilennummer, auf der das Makro aufgerufen wird
#define LOG(level, format, ...) app_log(level, __FILE__, __LINE__, __LINE__, format, ##__VA_ARGS__) 

// ZENTRALER LOGGER DEFINITION (MUSS HIER STEHEN, BEVOR IRGENDEINE KLASSE LOG VERWENDET)
void app_log(LogLevel level, const char* file, int line, int logLine, const char* format, ...) {
    const char* levelStr = "UNKNOWN";
    switch (level) {
        case LOG_DEBUG: levelStr = "DEBUG"; break;
        case LOG_INFO:  levelStr = "INFO";  break;
        case LOG_WARN:  levelStr = "WARNUNG"; break;
        case LOG_ERROR: levelStr = "FEHLER"; break;
    }
    
    unsigned long timeMs = millis();
    char logBuffer[256];
    
    // Wir verwenden logLine, da __LINE__ auf das Makro selbst zeigt
    int len = snprintf(logBuffer, sizeof(logBuffer), "[%lu ms] [%s] (%s:%d) ", 
                       timeMs, levelStr, file, logLine);

    va_list args;
    va_start(args, format);
    vsnprintf(logBuffer + len, sizeof(logBuffer) - len, format, args);
    va_end(args);
    
    Serial.println(logBuffer);
}

// --- Z√úNDUNGSKONFIGURATION ---
const int IGNITION_INPUT_PIN = D1;  
const int IGNITION_OUTPUT_PIN = D2; 

// --- GLOBALE KONFIGURATION & PIN-DEFS ---
const int ADC_PIN = A0; // Dedizierter Pin f√ºr Hall/TPS Sensor

// PIN PLATZHALTER (f√ºr digitale Eing√§nge)
const int PIN_LIGHT_IN    = D5; 
const int PIN_FARLIGHT_IN = D6; 
const int PIN_BRAKE_IN    = D7;
const int PIN_BLINK_LEFT  = D0; 
const int PIN_BLINK_RIGHT = D3; 

// --- RPM Konfiguration (Wird aus JSON geladen) ---
struct RpmConfig {
    volatile int pulses_per_revolution; 
    volatile bool is_digital; 
    volatile int input_pin;
} rpmConfig = {1, true, IGNITION_INPUT_PIN}; 

// --- Z√ºndungs-Timing Konfiguration (Wird aus JSON geladen) ---
struct IgnitionTimingConfig {
    volatile int trigger_offset_deg; 
    volatile float TDC_adjust_deg;  
} timingConfig = {60, 0.0f}; 

// --- NEU: Z√ºndspulen-Konfiguration (Wird aus JSON geladen) ---
struct IgnitionCoilConfig {
    volatile float primary_resistance_ohm;  // Rp (Interner Widerstand der Spule)
    volatile float external_resistance_ohm; // R_ext (Externer Vorwiderstand in Reihe)
    volatile float primary_inductance_mH;   // Lp (Induktivit√§t, in MillihEnry [mH])
    volatile float target_current_A;        // I_target (Zielstrom, in Ampere [A])
    volatile float fixed_dwell_ms;          // Statische Dwell-Zeit (Fallback, ms)
} coilConfig = {0.2f, 2.0f, 4.0f, 8.0f, 3.5f}; // Beispielwerte


// --- ZENTRALE DATENSTRUKTUREN ---

// Z√ºndungstimer
struct IgnitionState {
    volatile unsigned long last_pulse_micros;
    volatile unsigned long period_micros;
    volatile int rpm;
    volatile unsigned long advance_micros;
    volatile bool pulse_detected;
} ignition = {0, 0, 0, 0, false};

// Zentrale Struktur f√ºr alle Sensor-Inputs
struct SensorState {
    // --- Basis-Steuerung ---
    volatile int tps_raw;               
    volatile int geschwindigkeit_kmh;    

    // --- Digitale/Boolean Eing√§nge ---
    volatile bool licht_ein_state;      
    volatile bool fernlicht_ein_state;  
    volatile bool bremslicht_state;     
    volatile bool blinker_links_state;  
    volatile bool blinker_rechts_state; 

    // --- Analoge/Temperatur Eing√§nge ---
    volatile float batteriespannung_v;       
    volatile float temperatur_zylinderkopf_c; 
    volatile float temperatur_luftfilterkasten_c; 
    volatile float temperatur_umgebung_c;    
    volatile float luftfeuchtigkeit_umgebung_pct; 
    
} sensor = {
    0, 0, // Basis
    false, false, false, false, false, // Digital
    0.0f, 0.0f, 0.0f, 0.0f, 0.0f // Analog/Float
};

// Kennfeld-Struktur
struct MapPoint {
    int rpm;
    int tps; // Throttle Position Sensor Wert (0-1023)
    int angle; // Grad vor OT
};
std::vector<MapPoint> ignitionMap;


// --- SENSOR ABSTRAKTION ---

// Enum zur Identifizierung jedes Sensors
enum SensorID {
    SID_TPS_RAW,
    SID_SPEED,
    SID_BATT_V,
    SID_TEMP_KOPF,
    SID_TEMP_LUFT,
    SID_TEMP_UMG,
    SID_FEUCHTIGKEIT,
    SID_LIGHT,
    SID_FARLIGHT,
    SID_BRAKE,
    SID_BLINK_L,
    SID_BLINK_R,
    SID_COUNT // Anzahl der definierten Sensoren
};

/**
 * Basisklasse f√ºr alle Sensoren (Abstrakte Schnittstelle). 
 */
class BaseSensor {
public:
    virtual ~BaseSensor() {}
    /** Gibt den gelesenen Wert als universellen Float zur√ºck. */
    virtual float readValue() = 0; 
    /** Gibt das minimale Leseintervall in Millisekunden zur√ºck. */
    virtual unsigned long getMinInterval() = 0;
};

// ----------------------------------------------------
// KONKRETE SENSOR-KLASSEN (Beispiele)
// ----------------------------------------------------

/**
 * Konkreter Sensor: Analoger TPS-Sensor (ADC).
 */
class TPS_Sensor : public BaseSensor {
private:
    const int _pin;
    const unsigned long _interval; 
public:
    TPS_Sensor(int pin, unsigned long interval_ms) : _pin(pin), _interval(interval_ms) {}
    unsigned long getMinInterval() override { return _interval; }
    
    float readValue() override { 
        return (float)analogRead(_pin);
    }
};

/**
 * Konkreter Sensor: Digitaler Eingang (z.B. Schalter).
 */
class DigitalInput_Sensor : public BaseSensor {
private:
    const int _pin;
    const unsigned long _interval;
    const bool _pullup;
public:
    DigitalInput_Sensor(int pin, unsigned long interval_ms, bool pullup = true) 
        : _pin(pin), _interval(interval_ms), _pullup(pullup) {
        pinMode(_pin, _pullup ? INPUT_PULLUP : INPUT);
    }
    unsigned long getMinInterval() override { return _interval; }

    float readValue() override {
        return (digitalRead(_pin) == (_pullup ? LOW : HIGH)) ? 1.0f : 0.0f;
    }
};

/**
 * Konkreter Sensor: Statische Messung/Simulation.
 */
class Static_Sensor : public BaseSensor {
private:
    const float _value;
    const unsigned long _interval;
public:
    Static_Sensor(float value, unsigned long interval_ms) 
        : _value(value), _interval(interval_ms) {}
    unsigned long getMinInterval() override { return _interval; }
    
    float readValue() override {
        return _value; 
    }
};

/**
 * Konkreter Sensor: Kalibrierte Analogmessung (z.B. Batteriespannung).
 */
class CalibratedAnalog_Sensor : public BaseSensor {
private:
    const float _adc_ref;    // 3.3V
    const float _divider_ratio; // Spannungsteilerfaktor (z.B. 11.0f f√ºr 11:1 Teiler)
    const unsigned long _interval; 
public:
    CalibratedAnalog_Sensor(float adc_ref, float divider_ratio, unsigned long interval_ms) 
        : _adc_ref(adc_ref), _divider_ratio(divider_ratio), _interval(interval_ms) {}
    
    unsigned long getMinInterval() override { return _interval; }

    float readRawADC() {
        // --- I/O Simulation (Wenn A0 nicht verf√ºgbar ist) ---
        return 350.0f; // Simulierter Rohwert, der 12.5V entspricht
    }

    float readValue() override {
        float adc_raw = readRawADC();
        
        float v_adc = adc_raw * (_adc_ref / 1023.0f);
        
        return v_adc * _divider_ratio;
    }
};


// ----------------------------------------------------
// I2C-Expander-Logik (Controller-Task)
// ----------------------------------------------------

/**
 * Verwaltet ein I2C/SPI Expanderboard als eigenst√§ndigen,
 * zeitgesteuerten Controller-Task.
 */
class I2C_Expander {
private:
    uint8_t _address;
    const unsigned long _interval;

public:
    unsigned long last_update_ms = 0; 
    
    I2C_Expander(uint8_t address, unsigned long interval_ms) : _address(address), _interval(interval_ms) {
        LOG(LOG_INFO, "Expander 0x%X initialisiert.", _address);
    }

    unsigned long getMinInterval() const { return _interval; }

    /** Simuliert das Lesen des gesamten I/O-Port-Registers */
    uint16_t readPort() {
        return 0b1010101010101010; // Simulation 16-Bit-Port
    }

    /** F√ºhrt die zeitraubende I2C-Kommunikation einmal durch und aktualisiert das SensorState */
    void execute() {
        uint16_t port_value = readPort();
        
        // --- Hier w√ºrden die Ports den SensorState aktualisieren ---
        if (_address == 0x20) {
            noInterrupts();
            sensor.blinker_links_state = (port_value & 0x0001); 
            sensor.blinker_rechts_state = (port_value & 0x0002);
            interrupts();
        }
        
        if (_address == 0x38) {
            noInterrupts();
            sensor.licht_ein_state = (port_value & 0x0004); 
            sensor.fernlicht_ein_state = (port_value & 0x0008); 
            interrupts();
        }
        
        LOG(LOG_DEBUG, "Expander 0x%X I/O gelesen. (Port: 0x%X)", _address, port_value);
    }
};

// ----------------------------------------------------
// GLOBALE I/O VERWALTUNG
// ----------------------------------------------------

// Vektor f√ºr schnelle, einzelne Sensoren (Round-Robin)
struct SensorTask {
    std::unique_ptr<BaseSensor> sensor_ptr;
    unsigned long last_update_ms = 0;
    SensorID target_id; // Zuordnung zum SensorState-Struct
};

std::vector<SensorTask> allSensorTasks;
static int current_task_index = 0;

// Vektor f√ºr langsame, komplexe I/O-Controller (I2C/SPI Expander)
std::vector<std::unique_ptr<I2C_Expander>> allExpanderTasks;


// --- STATISTIK & RESSOURCEN ---
const int STATS_WINDOW_SIZE = 100; 
const unsigned long MAX_LOOP_DURATION_US = 10000;
const char *LOG_FILENAME = "/critical_log.txt";
const int MAX_LOG_LINES = 100;
const unsigned long MIN_HEAP_WARNING = 5000;

volatile unsigned long loop_durations_buffer[STATS_WINDOW_SIZE];
volatile int stats_index = 0;
volatile unsigned long max_loop_duration_us = 0;
volatile unsigned long min_loop_duration_us = 999999;
volatile unsigned long avg_loop_duration_us = 0;
volatile unsigned long last_critical_max_duration_us = 0;
volatile unsigned long last_critical_timestamp_ms = 0;
volatile bool is_critical_latency_active = false;

// --- Zeitbasiertes Web-Handling ---
unsigned long lastWebHandle = 0;
unsigned long lastOtaHandle = 0;
unsigned long lastHeapCheck = 0;
const unsigned long WEB_HANDLE_INTERVAL = 200;
const unsigned long OTA_HANDLE_INTERVAL = 1000; 
const unsigned long HEAP_CHECK_INTERVAL = 5000;

volatile unsigned long server_start_delay_ms = 30000;
volatile unsigned long boot_time_ms = 0;
static int calc_counter = 0;
const int CALC_FREQUENCY = 100;


// --- NOTFALL-FALLBACK KENNFIELD (PROGMEM) ---
// Alle neuen Felder sind hier mit ihren Standardwerten enthalten
const char* FALLBACK_CURVE_JSON = R"({"ssid": "", "password": "", "ap_ssid": "esp-aktor", "ap_password": "MeinSicheresPasswort", "rpm_pulses": 1, "rpm_type": true, "timing_offset": 60, "timing_tdc": 0.0, "primary_resistance_ohm": 0.2, "external_resistance_ohm": 2.0, "primary_inductance_mH": 4.0, "target_current_A": 8.0, "fixed_dwell_ms": 3.5, "map": [
    {"rpm": 0,    "tps": 0,    "angle": 10},  
    {"rpm": 0,    "tps": 1023, "angle": 10},  
    {"rpm": 1000, "tps": 0,    "angle": 25},  
    {"rpm": 1000, "tps": 1023, "angle": 15},  
    {"rpm": 4000, "tps": 0,    "angle": 20},
    {"rpm": 4000, "tps": 1023, "angle": 12},
    {"rpm": 8000, "tps": 0,    "angle": 15},
    {"rpm": 8000, "tps": 1023, "angle": 8}   
]})"; 


// Ticker-Instanzen
Ticker advanceTicker;
Ticker debugTicker; 

// --- ANDERE KONFIGURATION ---
const int LED_PIN = D4;     
const int BUTTON_PIN = D5;  
const char* HTTP_USERNAME = "admin"; // Bleibt fest codiert

// Globale Variablen f√ºr STA und AP Konfiguration
String wifiSsid = ""; 
String wifiPassword = "";
String apSsid = "esp-aktor"; 
String apPassword = "MeinSicheresPasswort"; 

bool ledState = false;          
bool serverStarted = false;     
bool startApMode = false;     

ESP8266WebServer server(80);

// =========================================================
// 2. FORWARD-DEKLARATIONEN DER HAUPTFUNKTIONEN
// =========================================================

// Deklarationen der Log- und Helper-Funktionen
void logCriticalEvent(unsigned long maxDuration, unsigned long timestamp, const char* status); 
bool loadConfig();
bool saveConfig();
bool isAuthorized(); 
int pinNameToCode(String pinName);
void setPinState(int pinCode, bool targetState); 
void calculateLoopStatistics();
void trimLogFile();
void checkHeapHealth();
bool loadMapFromJson(const char* jsonString);
int getAdvanceAngle2D(int rpm, int tps);
void updateIgnitionParameters();
void updateSensorState(SensorID id, float value); 
void updateSensorsRoundRobin();
void updateSlowIOControllers(); 

// Deklarationen der Serverfunktionen
void setup_server_routes(); 
void setup_ota(); 
void handleRoot();          
void handleSetAktor();      
void handleConfig();        
void handleSaveConfig();    
void handleViewLog();       
void handleClearLog();      
void handleCurveConfig();    
void handleSaveCurve();      
void handleRestoreCurve();   
void handleRpmConfig();
void handleSaveRpmConfig();

// Deklarationen der kritischen Getter 
unsigned long getIgnitionPeriodSafe();
int getIgnitionRpmSafe();
unsigned long getAdvanceMicrosSafe();

// =========================================================
// 3. FUNKTIONSDEFINITIONEN
// =========================================================

// Definition der kritischen Getter 
unsigned long getIgnitionPeriodSafe() {
    noInterrupts();
    unsigned long period = ignition.period_micros;
    interrupts();
    return period;
}

int getIgnitionRpmSafe() {
    noInterrupts();
    int rpm = ignition.rpm;
    interrupts();
    return rpm;
}

unsigned long getAdvanceMicrosSafe() {
    noInterrupts();
    unsigned long advance = ignition.advance_micros;
    interrupts();
    return advance;
}


int getAdvanceAngle2D(int rpm, int tps) {
    if (ignitionMap.empty()) return 0; 
    
    std::vector<MapPoint> currentMap;
    noInterrupts();
    currentMap = ignitionMap;
    interrupts();
    
    if (currentMap.size() > 1) {
         std::sort(currentMap.begin(), currentMap.end(), [](const MapPoint& a, const MapPoint& b) {
            if (a.rpm != b.rpm) return a.rpm < b.rpm;
            return a.tps < b.tps;
         });
    }

    int min_rpm = currentMap.front().rpm;
    int max_rpm = currentMap.back().rpm;
    int min_tps = 1024, max_tps = 0;
    
    for (const auto& p : currentMap) {
        min_tps = std::min(min_tps, p.tps);
        max_tps = std::max(max_tps, p.tps);
        min_rpm = std::min(min_rpm, p.rpm);
        max_rpm = std::max(max_rpm, p.rpm);
    }
    
    if (rpm <= min_rpm && tps <= min_tps) return currentMap.front().angle;
    if (rpm >= max_rpm && tps >= max_tps) return currentMap.back().angle;

    int rpm1 = -1, rpm2 = -1;
    int tps1 = -1, tps2 = -1;
    
    for (const auto& p : currentMap) {
        if (p.rpm <= rpm) rpm1 = std::max(rpm1, p.rpm);
        if (p.rpm > rpm) {
            if (rpm2 == -1 || p.rpm < rpm2) rpm2 = p.rpm;
        }
    }
    for (const auto& p : currentMap) {
        if (p.tps <= tps) tps1 = std::max(tps1, p.tps);
        if (p.tps > tps) {
            if (tps2 == -1 || p.tps < tps2) tps2 = p.tps;
        }
    }
    
    if (rpm1 == -1 || rpm2 == -1 || tps1 == -1 || tps2 == -1 || rpm1 == rpm2 || tps1 == tps2) {
        int best_angle = currentMap.front().angle;
        float min_diff = 1e9;
        
        for (const auto& p : currentMap) {
            float diff = std::abs(p.rpm - rpm) + std::abs(p.tps - tps) * 10;
            if (diff < min_diff) {
                min_diff = diff;
                best_angle = p.angle;
            }
        }
        return best_angle;
    }

    float a11 = 0, a21 = 0, a12 = 0, a22 = 0;
    
    auto find_angle = [&](int r, int t) -> float {
        for (const auto& p : currentMap) {
            if (p.rpm == r && p.tps == t) return (float)p.angle;
        }
        return 0.0f; 
    };
    
    a11 = find_angle(rpm1, tps1);
    a21 = find_angle(rpm2, tps1);
    a12 = find_angle(rpm1, tps2);
    a22 = find_angle(rpm2, tps2);
    
    float r_range = (float)(rpm2 - rpm1);
    float t_range = (float)(tps2 - tps1);
    
    if (r_range == 0.0f || t_range == 0.0f) return (int)a11; 

    float R = (float)(rpm - rpm1) / r_range;
    
    float a_tps1 = a11 * (1.0f - R) + a21 * R; 
    float a_tps2 = a12 * (1.0f - R) + a22 * R; 

    float T = (float)(tps - tps1) / t_range;
    
    float final_angle = a_tps1 * (1.0f - T) + a_tps2 * T;
    
    return (int)std::round(final_angle);
}

void IRAM_ATTR fireIgnitionOutput() {
    digitalWrite(IGNITION_OUTPUT_PIN, HIGH);
    delayMicroseconds(50); 
    digitalWrite(IGNITION_OUTPUT_PIN, LOW);
}

void IRAM_ATTR handleIgnitionPulse() {
    unsigned long current_micros = micros();

    if (ignition.last_pulse_micros != 0) {
        ignition.period_micros = current_micros - ignition.last_pulse_micros;

        if (ignition.period_micros > 1000) {
            
            // Berechnung der RPM mit Kalibrierungs-Offset
            // RPM = (60.000.000 / Perioden-¬µs) / Impulse pro Umdrehung
            if (rpmConfig.pulses_per_revolution > 0) {
                ignition.rpm = (60000000UL / ignition.period_micros) / rpmConfig.pulses_per_revolution;
            } else {
                 ignition.rpm = 0;
            }
            
        }

        unsigned long required_advance = ignition.advance_micros;

        if (required_advance > 100 && required_advance < ignition.period_micros) {
            timer1_attachInterrupt(fireIgnitionOutput);
            timer1_enable(TIM_DIV1, TIM_EDGE, TIM_SINGLE);
            timer1_write(required_advance * 5);
        }
    }

    ignition.last_pulse_micros = current_micros;
    ignition.pulse_detected = true;
}

/**
 * Speichert das Ergebnis des Sensors (value) an der richtigen Stelle (id)
 * im globalen SensorState-Struct.
 */
void updateSensorState(SensorID id, float value) {
    switch(id) {
        // Int-Werte (m√ºssen gerundet/gecastet werden)
        case SID_TPS_RAW: 
            sensor.tps_raw = (int)std::round(value);
            // Sonderlogik f√ºr Bremslicht (da es vom TPS abh√§ngt)
            sensor.bremslicht_state = (sensor.tps_raw > 500); 
            break;
            
        case SID_SPEED: 
            sensor.geschwindigkeit_kmh = (int)std::round(value); 
            break;
        
        // Float-Werte
        case SID_BATT_V: 
            sensor.batteriespannung_v = value; 
            break;
        case SID_TEMP_KOPF: 
            sensor.temperatur_zylinderkopf_c = value; 
            break;
        case SID_TEMP_LUFT: 
            sensor.temperatur_luftfilterkasten_c = value; 
            break;
        case SID_TEMP_UMG: 
            sensor.temperatur_umgebung_c = value; 
            break;
        case SID_FEUCHTIGKEIT: 
            sensor.luftfeuchtigkeit_umgebung_pct = value; 
            break;

        // Bool/Digitale Werte (Wert > 0.5f = true)
        case SID_LIGHT: 
            sensor.licht_ein_state = (value > 0.5f); 
            break; 
        case SID_FARLIGHT:
            sensor.fernlicht_ein_state = (value > 0.5f);
            break;
        case SID_BLINK_L:
            sensor.blinker_links_state = (value > 0.5f);
            break;
        case SID_BLINK_R:
            sensor.blinker_rechts_state = (value > 0.5f);
            break;

        default:
            break;
    }
}


/**
 * F√ºhrt die Round-Robin-Aktualisierung der schnellen BaseSensoren durch.
 */
void updateSensorsRoundRobin() {
    if (allSensorTasks.empty()) return;
    
    unsigned long current_time = millis();

    // 1. W√§hle die aktuelle Task (Round-Robin)
    SensorTask& currentTask = allSensorTasks[current_task_index];

    // 2. Pr√ºfe, ob die minimale Update-Zeit f√ºr DIESEN Sensor abgelaufen ist
    if ((current_time - currentTask.last_update_ms) >= currentTask.sensor_ptr->getMinInterval()) {
        
        noInterrupts();
        
        // 3. Polymorpher Aufruf: Ruft die spezifische readValue() des Objekts auf
        float value = currentTask.sensor_ptr->readValue(); 
        
        // 4. Speichere das Ergebnis an der korrekten Stelle im SensorState
        updateSensorState(currentTask.target_id, value);
        
        currentTask.last_update_ms = current_time; 
        interrupts();
    }
    
    // 5. N√§chste Task w√§hlen (Round-Robin)
    current_task_index = (current_task_index + 1) % allSensorTasks.size();
}


/**
 * F√ºhrt die zeitgesteuerte Aktualisierung aller I2C/SPI Expander/Controller durch.
 */
void updateSlowIOControllers() {
    if (allExpanderTasks.empty()) return;
    
    unsigned long current_time = millis();
    
    for (auto& expander : allExpanderTasks) {
        if ((current_time - expander->last_update_ms) >= expander->getMinInterval()) {
            
            noInterrupts();
            expander->execute(); 
            expander->last_update_ms = current_time;
            interrupts();
        }
    }
}

void updateIgnitionParameters() {
    // 1. Schnelle I/O (TPS, etc.)
    updateSensorsRoundRobin(); 
    
    // 2. Langsame I/O (Expander, Tr√§ge Sensoren)
    updateSlowIOControllers(); 

    int rpm_copy = getIgnitionRpmSafe();
    unsigned long period = getIgnitionPeriodSafe();
    
    int tps_value;
    noInterrupts();
    tps_value = sensor.tps_raw;
    interrupts();

    // Hinweis: Hier m√ºsste sp√§ter die dynamische Dwell-Berechnung 
    // unter Verwendung von coilConfig.primary_resistance_ohm und coilConfig.external_resistance_ohm erfolgen.
    
    int advance_angle = getAdvanceAngle2D(rpm_copy, tps_value); 

    if (period > 1000) {
        unsigned long required_time = (unsigned long)((float)advance_angle * (float)period / 360.0f);
        noInterrupts();
        ignition.advance_micros = required_time;
        interrupts();
    } else {
        noInterrupts();
        ignition.advance_micros = 0;
        interrupts();
    }
}


// =========================================================
// 4. STATISTIK & LOGGING-LOGIK 
// =========================================================

void trimLogFile() {
    if (!LittleFS.begin()) return;

    File logFile = LittleFS.open(LOG_FILENAME, "r");
    if (!logFile) return;

    std::vector<String> lines;
    while (logFile.available()) {
        String line = logFile.readStringUntil('\n');
        line.trim();
        if (line.length() > 0) {
            lines.push_back(line);
        }
    }
    logFile.close();

    if (lines.size() <= MAX_LOG_LINES) return;

    LOG(LOG_WARN, "Logdatei zu gro√ü (%d Zeilen), k√ºrze...", lines.size());

    std::vector<String> trimmed_lines;
    for (size_t i = lines.size() - MAX_LOG_LINES; i < lines.size(); ++i) {
        trimmed_lines.push_back(lines[i]);
    }
    
    LittleFS.remove(LOG_FILENAME);
    File newLogFile = LittleFS.open(LOG_FILENAME, "w");
    if (!newLogFile) return;

    for (const String& line : trimmed_lines) {
        newLogFile.println(line);
    }
    newLogFile.close();
    LOG(LOG_INFO, "Logdatei auf %d Zeilen gek√ºrzt.");
}


void logCriticalEvent(unsigned long maxDuration, unsigned long timestamp, const char* status) {
    if (!LittleFS.begin()) {
        LOG(LOG_ERROR, "LittleFS nicht verf√ºgbar f√ºr Logging.");
        return;
    }
    
    if (timestamp != 0) trimLogFile();

    String logEntry = String(status);
    logEntry += F(";MAX=");
    logEntry += String(maxDuration);
    logEntry += F(";TIME_MS=");
    logEntry += String(timestamp);

    File logFile = LittleFS.open(LOG_FILENAME, "a");
    if (!logFile) {
        LOG(LOG_ERROR, "Fehler beim √ñffnen der Logdatei zum Schreiben.");
        return;
    }

    logFile.println(logEntry); 
    logFile.close();
    
    if (timestamp != 0) {
        LOG(LOG_WARN, "Kritischer Eintrag gespeichert: %s", logEntry.c_str());
    } else {
        LOG(LOG_INFO, "Boot-Stempel gespeichert: %s", logEntry.c_str());
    }
}


void calculateLoopStatistics() {
    if (++calc_counter < CALC_FREQUENCY) return;
    calc_counter = 0;

    unsigned long sum = 0;
    unsigned long current_max = 0;
    unsigned long current_min = 999999;
    
    for (int i = 0; i < STATS_WINDOW_SIZE; i++) {
        unsigned long value = loop_durations_buffer[i];
        
        sum += value;
        
        if (value > current_max) {
            current_max = value;
        }
        if (value < current_min && value > 0) {
            current_min = value;
        }
    }
    
    avg_loop_duration_us = sum / STATS_WINDOW_SIZE;
    max_loop_duration_us = current_max;
    min_loop_duration_us = current_min;
}

void checkHeapHealth() {
    uint32_t freeHeap = ESP.getFreeHeap();

    if (freeHeap < MIN_HEAP_WARNING) {
        LOG(LOG_WARN, "‚ö†Ô∏è Heap niedrig: %d Bytes frei!", freeHeap);
    }

    if (freeHeap < 2000) {
        LOG(LOG_ERROR, "üö® KRITISCH: Nur noch %d Bytes Heap! Neustart empfohlen.", freeHeap);
    }
}


// =========================================================
// 5. DEBUG-FUNKTION 
// =========================================================

void printLoopStatus() {
    int rpm = getIgnitionRpmSafe();
    unsigned long advance = getAdvanceMicrosSafe();
    
    // Lese alle relevanten Sensor-Werte sicher aus dem Struct
    int tps_raw;
    float temp_kopf;
    float batt_v;
    bool licht_on;
    
    noInterrupts();
    tps_raw = sensor.tps_raw;
    temp_kopf = sensor.temperatur_zylinderkopf_c;
    batt_v = sensor.batteriespannung_v;
    licht_on = sensor.licht_ein_state;
    interrupts();
    
    // F√ºhre alle Echtzeit- und Sensorwerte im Log zusammen
    LOG(LOG_DEBUG, "RPM:%d | TPS:%d | ADV:%lu¬µs | L(%lu/%lu)¬µs | CHT:%.1f¬∞C | BAT:%.1fV | Light:%d | Heap:%d", 
        rpm, 
        tps_raw, 
        advance, 
        max_loop_duration_us, 
        avg_loop_duration_us, 
        temp_kopf, 
        batt_v,
        (int)licht_on,
        ESP.getFreeHeap());

    if (max_loop_duration_us > MAX_LOOP_DURATION_US) {
        if (!is_critical_latency_active) {
          is_critical_latency_active = true;
          last_critical_max_duration_us = max_loop_duration_us;
          last_critical_timestamp_ms = millis();
          
          logCriticalEvent(last_critical_max_duration_us, last_critical_timestamp_ms, "CRITICAL"); 
        }
        LOG(LOG_WARN, "Latenz kritisch! Max: %lu ¬µs", max_loop_duration_us);
                      
        if (max_loop_duration_us > MAX_LOOP_DURATION_US * 2) {
             LOG(LOG_ERROR, "Latenz extrem! Neustart empfohlen!");
        }
    } else {
        is_critical_latency_active = false; 
    }
}


// =========================================================
// 6. HANDLER & CONFIG IMPLEMENTIERUNGEN 
// =========================================================

// FEHLERBEHEBUNG: Verwendet nun apPassword
bool isAuthorized() { return server.authenticate(HTTP_USERNAME, apPassword.c_str()); }

int pinNameToCode(String pinName) {
    pinName.toUpperCase();
    
    if (pinName.length() != 2 || pinName[0] != 'D') {
        return -1;
    }
    
    switch (pinName[1]) {
        case '1': return D1;
        case '2': return D2;
        case '4': return D4;
        case '5': return D5;
        default: return -1;
    }
}

void setPinState(int pinCode, bool targetState) { 
  if (pinCode == -1) return;

  if (pinCode == LED_PIN) {
      digitalWrite(pinCode, targetState ? LOW : HIGH); 
      ledState = targetState;
  } else {
      digitalWrite(pinCode, targetState ? HIGH : LOW);
  }
  LOG(LOG_DEBUG, "Pin %d -> %s", pinCode, targetState ? "HIGH" : "LOW");
}

bool loadMapFromJson(const char* jsonString) {
    StaticJsonDocument<2048> doc; 
    DeserializationError error = deserializeJson(doc, jsonString);

    if (error) {
        LOG(LOG_ERROR, "Fehler beim Parsen des Kennfelds: %s", error.c_str());
        return false;
    }

    // --- STA Config laden ---
    wifiSsid = doc[F("ssid")].as<String>();
    wifiPassword = doc[F("password")].as<String>();
    
    // --- AP Config laden (mit Fallback) ---
    apSsid = doc[F("ap_ssid")] | "esp-aktor";
    apPassword = doc[F("ap_password")] | "MeinSicheresPasswort";
    
    // --- RPM und Timing Configs laden (mit Fallback) ---
    rpmConfig.pulses_per_revolution = doc[F("rpm_pulses")] | 1;
    rpmConfig.is_digital = doc[F("rpm_type")] | true;
    timingConfig.trigger_offset_deg = doc[F("timing_offset")] | 60;
    timingConfig.TDC_adjust_deg = doc[F("timing_tdc")] | 0.0f;
    
    // --- NEU: Z√ºndspulen Configs laden (mit Fallback) ---
    coilConfig.primary_resistance_ohm = doc[F("primary_resistance_ohm")] | 0.2f;
    coilConfig.external_resistance_ohm = doc[F("external_resistance_ohm")] | 2.0f;
    coilConfig.primary_inductance_mH = doc[F("primary_inductance_mH")] | 4.0f;
    coilConfig.target_current_A = doc[F("target_current_A")] | 8.0f;
    coilConfig.fixed_dwell_ms = doc[F("fixed_dwell_ms")] | 3.5f;

    
    // --- Map Array laden ---
    JsonArray mapArray = doc[F("map")].as<JsonArray>(); 
    ignitionMap.clear();
  
    for (JsonObject point : mapArray) {
        if (point.containsKey(F("rpm")) && point.containsKey(F("tps")) && point.containsKey(F("angle"))) {
            ignitionMap.push_back({point[F("rpm")], point[F("tps")], point[F("angle")]});
        }
    }
    
    if (ignitionMap.size() > 1) {
         std::sort(ignitionMap.begin(), ignitionMap.end(), [](const MapPoint& a, const MapPoint& b) {
            if (a.rpm != b.rpm) return a.rpm < b.rpm;
            return a.tps < b.tps;
         });
    }

    if (ignitionMap.empty()) {
        return false;
    }
    
    return true;
}


bool loadConfig() { 
  File configFile = LittleFS.open(F("/config.json"), "r");
  
  if (configFile) {
      size_t size = configFile.size();
      std::unique_ptr<char[]> buf(new char[size]);
      configFile.readBytes(buf.get(), size);
      configFile.close();

      if (loadMapFromJson(buf.get())) {
          LOG(LOG_INFO, "Konfiguration geladen. Kennfeldpunkte: %d", ignitionMap.size());
          return true;
      }
      LOG(LOG_WARN, "config.json korrupt oder unvollst√§ndig. Versuche Fallback.");
  }
  
  if (loadMapFromJson(FALLBACK_CURVE_JSON)) {
      LOG(LOG_INFO, "Fallback-Kennfeld geladen.");
      return true;
  }
  
  LOG(LOG_ERROR, "KRITISCHER FEHLER: Fallback-Kennfeld ung√ºltig. System instabil.");
  return false;
}

bool saveConfig() { 
  if (wifiSsid.length() > 32) { 
    LOG(LOG_ERROR, "Ung√ºltige STA SSID-L√§nge: %d", wifiSsid.length());
    return false;
  }
  
  if (apSsid.length() > 32 || (apPassword.length() > 0 && apPassword.length() < 8)) {
    LOG(LOG_ERROR, "Ung√ºltige AP SSID/Passwort-L√§nge.");
    return false;
  }
  
  StaticJsonDocument<2048> doc; 

  // STA (Client) Konfiguration
  doc[F("ssid")] = wifiSsid;
  doc[F("password")] = wifiPassword;
  
  // AP Konfiguration speichern
  doc[F("ap_ssid")] = apSsid;
  doc[F("ap_password")] = apPassword;
  
  // RPM und Timing Configs speichern
  doc[F("rpm_pulses")] = rpmConfig.pulses_per_revolution;
  doc[F("rpm_type")] = rpmConfig.is_digital;
  doc[F("timing_offset")] = timingConfig.trigger_offset_deg;
  doc[F("timing_tdc")] = timingConfig.TDC_adjust_deg;
  
  // NEU: Z√ºndspulen Configs speichern
  doc[F("primary_resistance_ohm")] = coilConfig.primary_resistance_ohm;
  doc[F("external_resistance_ohm")] = coilConfig.external_resistance_ohm;
  doc[F("primary_inductance_mH")] = coilConfig.primary_inductance_mH;
  doc[F("target_current_A")] = coilConfig.target_current_A;
  doc[F("fixed_dwell_ms")] = coilConfig.fixed_dwell_ms;

  // Kennfeld speichern
  JsonArray mapArray = doc.createNestedArray(F("map")); 
  for (const auto& point : ignitionMap) {
      JsonObject obj = mapArray.createNestedObject();
      obj[F("rpm")] = point.rpm;
      obj[F("tps")] = point.tps;
      obj[F("angle")] = point.angle;
  }

  File configFile = LittleFS.open(F("/config.json"), "w");
  if (!configFile) { 
    LOG(LOG_ERROR, "Config-Datei konnte nicht zum Schreiben ge√∂ffnet werden."); 
    return false;
  }
  
  if (serializeJson(doc, configFile) == 0) { 
    configFile.close(); 
    LOG(LOG_ERROR, "JSON Serialize Error.");
    return false; 
  }
  configFile.close();
  LOG(LOG_INFO, "Config gespeichert.");
  return true;
}

void handleRoot() {
    if (!isAuthorized()) return server.requestAuthentication();
    
    String ledStatus = ledState ? F("AN") : F("AUS");
    String linkUrl = "/set?pin=D4&state=" + String(ledState ? "0" : "1"); 
    String buttonRaw = (digitalRead(BUTTON_PIN) == LOW) ? F("<b style='color: red;'>GEDR√úCKT</b>") : F("Offen");
    
    // NEU: Lokale Variablen f√ºr das Dashboard deklarieren und volatile Daten sicher lesen
    int tpsValue;
    float voltage_value; 
    bool licht;
    bool fernlicht;
    bool bremse;
    bool blink_l;
    bool blink_r;
    int speed;
    float temp_kopf;
    float temp_luft;
    float temp_umg;
    float feuchtigkeit;
    float batt_v;
    
    noInterrupts();
    tpsValue     = sensor.tps_raw;
    licht        = sensor.licht_ein_state;
    fernlicht    = sensor.fernlicht_ein_state;
    bremse       = sensor.bremslicht_state;
    blink_l      = sensor.blinker_links_state;
    blink_r      = sensor.blinker_rechts_state;
    speed        = sensor.geschwindigkeit_kmh;
    temp_kopf    = sensor.temperatur_zylinderkopf_c;
    temp_luft    = sensor.temperatur_luftfilterkasten_c;
    temp_umg     = sensor.temperatur_umgebung_c;
    feuchtigkeit = sensor.luftfeuchtigkeit_umgebung_pct;
    batt_v       = sensor.batteriespannung_v;
    interrupts();
    
    // Berechnung der Spannung f√ºr die Anzeige
    voltage_value = (float)tpsValue * (3.3 / 1024.0); 

    int rpm = getIgnitionRpmSafe();
    unsigned long advance = getAdvanceMicrosSafe();
    
    String html = F("<html><head><meta charset='UTF-8'><meta http-equiv='refresh' content='3'></head><body>"); 
    html += F("<h1>Wemos D1 Mini - Z√ºndungssteuerung (2D-Kennfeld)</h1>");
    
    if (is_critical_latency_active) {
        unsigned long seconds = last_critical_timestamp_ms / 1000;
        
        html += F("<div style='padding:10px;background:#ffcccc;border:2px solid red;margin-bottom:15px;'>");
        html += F("<h2>üö® KRITISCHE LATENZ!</h2>");
        html += F("<p><b>Schwellenwert:</b> "); html += String(MAX_LOOP_DURATION_US); html += F(" ¬µs</p>");
        html += F("<p><b>Gemessen:</b> "); html += String(last_critical_max_duration_us); html += F(" ¬µs</p>");
        html += F("<p><b>Zeitstempel:</b> "); html += String(seconds); html += F(" s seit Boot</p>");
        html += F("</div>");
    }
    
    html += F("<h2>Status</h2><p><b>Modus:</b> ");
    html += WiFi.getMode() == WIFI_STA ? F("Client") : F("AP");
    html += F("</p><p><b>IP:</b> "); html += WiFi.localIP().toString();
    html += F("</p><p><b>Heap:</b> "); html += String(ESP.getFreeHeap()); html += F(" Bytes</p>");
    
    // Anzeige der RPM- und Timing-Konfiguration
    html += F("<h3>Z√ºndungs-Konfiguration</h3>");
    html += F("<table border='0' cellpadding='2'>");
    html += F("<tr><td>RPM Impulse/Umdr:</td><td><b>"); html += String(rpmConfig.pulses_per_revolution); html += F("</b></td></tr>");
    html += F("<tr><td>Trigger Offset:</td><td><b>"); html += String(timingConfig.trigger_offset_deg); html += F(" ¬∞ v.OT</b></td></tr>");
    html += F("<tr><td>Spulenwiderstand (Rp + R_ext):</td><td><b>"); html += String(coilConfig.primary_resistance_ohm + coilConfig.external_resistance_ohm, 1); html += F(" &Omega;</b> ("); html += String(coilConfig.external_resistance_ohm, 1); html += F(" &Omega; extern)</td></tr>");
    html += F("<tr><td>Induktivit√§t (Lp):</td><td><b>"); html += String(coilConfig.primary_inductance_mH, 1); html += F(" mH</b></td></tr>");
    html += F("</table>");
    html += F("<p><a href='/rpmconfig'>[Einstellungen √§ndern]</a></p>");


    html += F("<h2>Z√ºndung (Echtzeit)</h2><table border='1' cellpadding='5'>");
    html += F("<tr><th>Parameter</th><th>Wert</th></tr>");
    html += F("<tr><td>RPM</td><td><b>"); html += String(rpm); html += F(" U/min</b></td></tr>");
    html += F("<tr><td>TPS (Last)</td><td><b>"); html += String(tpsValue); 
    html += F(" ("); html += String(voltage_value, 2); html += F(" V)</b></td></tr>"); 
    html += F("<tr><td>Z√ºndwinkel</td><td><b>"); html += String(getAdvanceAngle2D(rpm, tpsValue)); html += F(" ¬∞ v.OT</b></td></tr>");
    html += F("<tr><td>Vorsprungzeit</td><td>"); html += String(advance); html += F(" ¬µs</td></tr>");

    // HINZUGEF√úGT: Loop-Statistiken im Z√ºndungsblock
    html += F("<tr><td colspan='2' style='text-align: center;'><b>Loop-Statistiken</b></td></tr>");
    
    String maxColor = max_loop_duration_us > MAX_LOOP_DURATION_US ? F("red") : F("green");
    
    html += F("<tr><td>Loop MAX Latenz</td><td><b style='color:"); html += maxColor; html += F("'>");
    html += String(max_loop_duration_us); html += F(" ¬µs</b></td></tr>");
    
    html += F("<tr><td>Loop AVG Latenz</td><td>"); html += String(avg_loop_duration_us); html += F(" ¬µs</td></tr>");
    html += F("<tr><td>Heap Free</td><td>"); html += String(ESP.getFreeHeap()); html += F(" Bytes</p></td></tr>");
    
    html += F("<tr><td colspan='2'><a href='/viewlog'>[Kritische Logs ansehen]</a></td></tr>");
    html += F("</table>");
    
    html += F("<h2>Sensor-Informationen</h2><table border='1' cellpadding='5'>");
    html += F("<tr><th>Sensor</th><th>Status / Wert</th></tr>");
    html += F("<tr><td>Geschwindigkeit</td><td><b>"); html += String(speed); html += F(" km/h</b></td></tr>");
    html += F("<tr><td>Batteriespannung</td><td><b>"); html += String(batt_v, 1); html += F(" V</b></td></tr>");
    html += F("<tr><td>Temp. Zylinderkopf</td><td><b>"); html += String(temp_kopf, 1); html += F(" ¬∞C</b></td></tr>");
    html += F("<tr><td>Temp. Luftfilterkasten</td><td><b>"); html += String(temp_luft, 1); html += F(" ¬∞C</b></td></tr>");
    html += F("<tr><td>Temp. Umgebung</td><td><b>"); html += String(temp_umg, 1); html += F(" ¬∞C</b></td></tr>");
    html += F("<tr><td>Luftfeuchtigkeit</td><td><b>"); html += String(feuchtigkeit, 1); html += F(" %</b></td></tr>");
    html += F("<tr><td>Licht</td><td><b>"); html += (licht ? F("AN") : F("AUS")); html += F("</b></td></tr>");
    html += F("<tr><td>Fernlicht</td><td><b>"); html += (fernlicht ? F("AN") : F("AUS")); html += F("</b></b></td></tr>");
    html += F("<tr><td>Bremslicht</td><td><b>"); html += (bremse ? F("AN") : F("AUS")); html += F("</b></b></td></tr>");
    html += F("<tr><td>Blinker Links</td><td><b>"); html += (blink_l ? F("AN") : F("AUS")); html += F("</b></td></tr>");
    html += F("<tr><td>Blinker Rechts</td><td><b>"); html += (blink_r ? F("AN") : F("AUS")); html += F("</b></td></tr>");
    html += F("</table>");
    
    html += F("<p><a href='/config'>‚öôÔ∏è WLAN-Config</a> | <a href='/curve'>üìà Z√ºndkennfeld-Config</a></p>");
    html += F("<p style='color:#666;font-size:0.9em;'>‚úÖ 2D-Kennfeld-Steuerung aktiv.</p>");
    html += F("</body></html>");
    
    server.send(200, "text/html", html);
}

void handleSetAktor() {
    if (!isAuthorized()) return server.requestAuthentication();

    if (!server.hasArg(F("pin")) || !server.hasArg(F("state"))) {
        server.send(400, "text/plain", F("Bad Request: pin und state erforderlich"));
        return;
    }

    int pinCode = pinNameToCode(server.arg(F("pin")));
    if (pinCode == -1) {
        server.send(400, "text/plain", F("Ung√ºltiger Pin"));
        return;
    }

    int state = server.arg(F("state")).toInt();
    setPinState(pinCode, state != 0);

    server.send(200, "text/plain", F("OK. Pin ") + server.arg(F("pin")) + F(" = ") + server.arg(F("state")));
}

void handleConfig() {
    if (!isAuthorized()) return server.requestAuthentication();

    String html = F("<html><head><meta charset='UTF-8'></head><body><h1>WLAN Konfiguration</h1>");
    
    html += F("<h2>Client Mode (STA)</h2>");
    html += F("<form method='post' action='/saveconfig'>");
    html += F("STA SSID: <input type='text' name='ssid' maxlength='32' value='");
    html += wifiSsid; html += F("'><br>");
    html += F("STA Passwort: <input type='password' name='password' minlength='8' value='");
    html += wifiPassword; html += F("'><br><br>");
    
    // NEU: AP Konfiguration
    html += F("<h2>Access Point Mode (AP - Fallback)</h2>");
    html += F("AP SSID (Hostname): <input type='text' name='ap_ssid' maxlength='32' value='");
    html += apSsid; html += F("'><br>");
    html += F("AP Passwort: <input type='password' name='ap_password' minlength='8' value='");
    html += apPassword; html += F("'><br><br>");
    
    html += F("<input type='submit' value='Speichern und Neustart'>");
    html += F("</form><p><a href='/'>Zur√ºck</a></p></body></html>");
    
    server.send(200, "text/html", html);
}

void handleSaveConfig() {
    if (!isAuthorized()) return server.requestAuthentication();

    if (!server.hasArg(F("ssid")) || !server.hasArg(F("password")) || !server.hasArg(F("ap_ssid")) || !server.hasArg(F("ap_password"))) {
        server.send(400, "text/plain", F("Bad Request: Alle Felder erforderlich."));
        return;
    }

    // STA Werte
    String newSsid = server.arg(F("ssid"));
    String newPass = server.arg(F("password"));
    
    // AP Werte
    String newApSsid = server.arg(F("ap_ssid"));
    String newApPass = server.arg(F("ap_password"));
    
    // Validierung (nur AP SSID/Passwort muss validiert werden)
    if (newApSsid.length() == 0 || newApSsid.length() > 32 || (newApPass.length() > 0 && newApPass.length() < 8)) {
        server.send(400, "text/plain", F("Fehler: AP SSID/Passwort ung√ºltig."));
        return;
    }

    wifiSsid = newSsid;
    wifiPassword = newPass;
    apSsid = newApSsid; 
    apPassword = newApPass; 

    if (saveConfig()) {
        server.send(200, F("text/plain"), F("Gespeichert. Neustart..."));
        delay(1000);
        ESP.restart();
    } else {
        server.send(500, F("text/plain"), F("Speichern fehlgeschlagen"));
    }
}

void handleViewLog() {
    if (!isAuthorized()) return server.requestAuthentication();

    File logFile = LittleFS.open(LOG_FILENAME, "r");
    if (!logFile) {
        server.send(200, "text/plain", F("Logdatei ist leer."));
        return;
    }
    
    String content = F("<html><head><meta charset='UTF-8'></head><body><h1>Kritische Latenz-Ereignisse</h1><pre>");
    content += F("Status;Maximaldauer (us);Zeitstempel (ms)\n");
    content += F("-------------------------------------------------\n");
    content += logFile.readString(); 
    logFile.close();
    content += F("</pre><p><a href='/'>Zur√ºck</a> | <a href='/clearlog'>L√∂schen</a></p></body></html>");

    server.send(200, "text/html", content);
}

void handleClearLog() {
    if (!isAuthorized()) return server.requestAuthentication();

    if (LittleFS.remove(LOG_FILENAME)) {
        LOG(LOG_INFO, "Logdatei gel√∂scht.");
        server.send(200, "text/plain", F("Log gel√∂scht. Neustart..."));
        delay(1000);
        ESP.restart();
    } else {
        LOG(LOG_ERROR, "Fehler beim L√∂schen.");
        server.send(500, "text/plain", F("L√∂schen fehlgeschlagen."));
    }
}

void handleCurveConfig() {
    if (!isAuthorized()) return server.requestAuthentication();

    String html = F("<html><head><meta charset='UTF-8'></head><body>");
    html += F("<h1>üìà Z√ºndkurven-Konfiguration</h1>");
    
    html += F("<form method='post' action='/savecurve'>");

    html += F("<table border='1' cellpadding='5'>");
    html += F("<tr><th>#</th><th>Drehzahl (RPM)</th><th>TPS (0-1023)</th><th>Winkel (¬∞ v. OT)</th><th>Aktion</th></tr>");

    std::vector<MapPoint> currentMap;
    noInterrupts();
    currentMap = ignitionMap;
    interrupts();

    for (size_t i = 0; i < currentMap.size(); ++i) {
        String idx = String(i);
        
        html += F("<tr><td>"); html += idx; html += F("</td>");
        
        html += F("<td><input type='number' name='rpm_"); html += idx; html += F("' value='");
        html += String(currentMap[i].rpm); html += F("' min='0' required></td>");

        html += F("<td><input type='number' name='tps_"); html += idx; html += F("' value='");
        html += String(currentMap[i].tps); html += F("' min='0' max='1023' required></td>");

        html += F("<td><input type='number' name='angle_"); html += idx; html += F("' value='");
        html += String(currentMap[i].angle); html += F("' min='-20' max='30' required></td>");

        html += F("<td><button type='submit' name='delete_idx' value='"); html += idx;
        html += F("'>L√∂schen</button></td></tr>");
    }

    String new_idx = String(currentMap.size());
    html += F("<tr><td>"); html += new_idx; html += F(" (Neu)</td>");
    html += F("<td><input type='number' name='rpm_"); html += new_idx; html += F("' value='' min='0' placeholder='RPM' ></td>");
    html += F("<td><input type='number' name='tps_"); html += new_idx; html += F("' value='' min='0' max='1023' placeholder='TPS' ></td>");
    html += F("<td><input type='number' name='angle_"); html += new_idx; html += F("' value='' min='-20' max='30' placeholder='Winkel' ></td>");
    html += F("<td></td></tr>"); 
    
    html += F("</table>");

    html += F("<br><h2>Aktionen</h2>");
    
    // NEU: On-the-Fly-Update Button
    html += F("<button type='submit' name='action' value='apply_only' style='background: #ffcc00;'>üß™ Im RAM Anwenden (Test)</button> ");
    
    // Speichern und Neustart
    html += F("<button type='submit' name='action' value='save_all'>‚úÖ Speichern auf Flash & Neustart</button>");
    
    html += F("</form>"); 

    html += F("<h2>Werkseinstellungen</h2>");
    html += F("<p>Stellt die Z√ºndkurve auf den unver√§nderlichen Firmware-Standard zur√ºck und startet neu.</p>");
    html += F("<form method='post' action='/restorecurve'>");
    html += F("<button type='submit'>‚ö†Ô∏è Standard-Kurve Wiederherstellen</button>");
    html += F("</form>");

    html += F("<p><a href='/'>Zur√ºck zum Dashboard</a></p></body></html>");
    
    server.send(200, "text/html", html);
}

void handleSaveCurve() {
    if (!isAuthorized()) return server.requestAuthentication();

    String action = server.arg(F("action"));
    
    String delete_idx_str = server.arg(F("delete_idx"));
    if (delete_idx_str.length() > 0) {
        int delete_index = delete_idx_str.toInt();
        
        noInterrupts();
        if (delete_index >= 0 && (size_t)delete_index < ignitionMap.size()) {
            ignitionMap.erase(ignitionMap.begin() + delete_index);
            LOG(LOG_INFO, "Kennfeldpunkt %d gel√∂scht.", delete_index);
        }
        interrupts();
        
        server.sendHeader(F("Location"), F("/curve"));
        server.send(303);
        return;
    }

    std::vector<MapPoint> newMap;
    
    for (int i = 0; i < server.args(); i++) {
        String argName = server.argName(i);
        
        if (argName.startsWith(F("rpm_"))) {
            int index = argName.substring(4).toInt();
            String rpmStr = server.arg(argName);
            String tpsStr = server.arg(F("tps_") + String(index));
            String angleStr = server.arg(F("angle_") + String(index));
            
            if (rpmStr.isEmpty() || tpsStr.isEmpty() || angleStr.isEmpty()) {
                if (action != F("add_new") || (size_t)index != ignitionMap.size()) {
                    continue; 
                }
            }
            
            if (rpmStr.isEmpty() || tpsStr.isEmpty() || angleStr.isEmpty()) {
                if (action == F("add_new") && (size_t)index == ignitionMap.size()) {
                     server.send(400, F("text/plain"), F("Fehler: Neuer Punkt muss RPM, TPS und Winkel haben."));
                     return;
                }
            }

            int rpm = rpmStr.toInt();
            int tps = tpsStr.toInt();
            int angle = angleStr.toInt();

            if (rpm < 0 || rpm > 15000 || tps < 0 || tps > 1023 || angle < -20 || angle > 30) {
                LOG(LOG_ERROR, "Ung√ºltige Kennfeldwerte (%d RPM, %d TPS, %d Angle).", rpm, tps, angle);
                server.send(400, F("text/plain"), F("Fehler: Ung√ºltige Werte f√ºr RPM/TPS/Winkel."));
                return;
            }

            newMap.push_back({rpm, tps, angle});
        }
    }

    if (newMap.size() > 1) {
        std::sort(newMap.begin(), newMap.end(), [](const MapPoint& a, const MapPoint& b) {
            if (a.rpm != b.rpm) return a.rpm < b.rpm;
            return a.tps < b.tps;
        });
    }

    // Kurve √ºbernehmen (in den RAM)
    noInterrupts();
    ignitionMap = newMap;
    interrupts();
    
    // 3. AKTIONEN AUSF√úHREN
    
    if (action == F("save_all")) {
        // AKTION: Speichern auf Flash und Neustart
        LOG(LOG_INFO, "Z√ºndkennfeld in RAM √ºbernommen. Speichere und starte neu.");
        if (saveConfig()) {
            server.send(200, F("text/plain"), F("Kennfeld gespeichert. Neustart..."));
            delay(1000);
            ESP.restart(); 
            return;
        } else {
            server.send(500, F("text/plain"), F("Fehler beim Speichern der Konfiguration."));
            return;
        }
    } 
    
    if (action == F("apply_only") || action == F("add_new")) {
        // AKTION: Nur im RAM anwenden (On-the-Fly-Update)
        LOG(LOG_INFO, "Z√ºndkennfeld erfolgreich in RAM angewendet. Punkte: %d", newMap.size());

        // Optimale UX: Seite mit automatischer Weiterleitung senden
        String responseHtml = F("<html><head><meta http-equiv='refresh' content='2;url=/curve'></head><body><h1>Erfolg!</h1><p>Konfiguration im RAM angewendet. Seite wird in 2 Sekunden neu geladen.</p><p><a href='/curve'>Manuell fortfahren</a></p></body></html>");
        server.send(200, F("text/html"), responseHtml);
        return;
    }
    
    // Fallback nach L√∂schen/Hinzuf√ºgen ohne explizites Save
    server.sendHeader(F("Location"), F("/curve"));
    server.send(303);
}

void handleRestoreCurve() {
    if (!isAuthorized()) return server.requestAuthentication();

    LOG(LOG_WARN, "Wiederherstellung des Standard-Z√ºndkennfelds angefordert.");

    if (loadMapFromJson(FALLBACK_CURVE_JSON)) {
        if (saveConfig()) {
            server.send(200, F("text/plain"), F("Standard-Kennfeld erfolgreich wiederhergestellt. Neustart..."));
            delay(1000);
            ESP.restart();
            return;
        }
    }
    
    server.send(500, F("text/plain"), F("Fehler: Konnte Standard-Kennfeld nicht speichern."));
}

void handleRpmConfig() {
    if (!isAuthorized()) return server.requestAuthentication();

    String html = F("<html><head><meta charset='UTF-8'></head><body><h1>RPM & Z√ºndungs-Timing Konfiguration</h1>");
    html += F("<form method='post' action='/saverpmconfig'>");
    
    // RPM Sektion
    html += F("<h2>RPM Sensor (Signalquelle)</h2>");
    html += F("<p><b>Pin:</b> D"); html += String(digitalPinToInterrupt(rpmConfig.input_pin)); html += F(" (fest verdrahtet)</p>");
    
    html += F("Impulse pro Umdrehung: <input type='number' name='pulses' min='1' max='20' value='");
    html += String(rpmConfig.pulses_per_revolution); html += F("' required><br>");
    
    // Sensortyp (Digital/Analog)
    html += F("Sensor Typ: <select name='is_digital'>");
    html += F("<option value='1' "); html += rpmConfig.is_digital ? F("selected") : F(""); html += F(">Digital (Hall / Optisch)</option>");
    html += F("<option value='0' "); html += !rpmConfig.is_digital ? F("selected") : F(""); html += F(">Analog (Induktiv / Sinus)</option>");
    html += F("</select><br><br>");
    
    // Timing Sektion
    html += F("<h2>Statische Z√ºndungs-Justierung (Mechanik)</h2>");
    html += F("Trigger Offset (&deg; v.OT): <input type='number' name='offset' min='0' max='360' value='");
    html += String(timingConfig.trigger_offset_deg); html += F("' required><br>");
    
    html += F("TDC Feinjustierung (&deg;): <input type='number' name='tdc' step='0.1' value='");
    html += String(timingConfig.TDC_adjust_deg, 1); html += F("' required><br><br>");

    // NEU: Spulen Sektion
    html += F("<h2>Z√ºndspule (Elektrische Kalibrierung)</h2>");
    html += F("Prim√§rwiderstand Spule (Rp in &Omega;): <input type='number' name='rp' step='0.1' value='");
    html += String(coilConfig.primary_resistance_ohm, 1); html += F("' min='0.1' required><br>");

    html += F("Externer Vorwiderstand (Rext in &Omega;): <input type='number' name='rext' step='0.1' value='");
    html += String(coilConfig.external_resistance_ohm, 1); html += F("' min='0.0' required><br>");

    html += F("Prim√§rinduktivit√§t (Lp in mH): <input type='number' name='lp' step='0.1' value='");
    html += String(coilConfig.primary_inductance_mH, 1); html += F("' min='0.1' required><br>");

    html += F("Ziel-Prim√§rstrom (I_target in A): <input type='number' name='itarget' step='0.1' value='");
    html += String(coilConfig.target_current_A, 1); html += F("' min='1.0' required><br>");

    html += F("Statische Dwell-Zeit (Fallback in ms): <input type='number' name='dwell' step='0.1' value='");
    html += String(coilConfig.fixed_dwell_ms, 1); html += F("' min='1.0' required><br><br>");
    
    // Aktionen
    html += F("<button type='submit' name='action' value='apply_only' style='background: #ffcc00;'>üß™ Im RAM Anwenden (Test)</button> ");
    html += F("<button type='submit' name='action' value='save_all'>‚úÖ Speichern auf Flash & Neustart</button>");
    
    html += F("</form><p><a href='/'>Zur√ºck</a></p></body></html>");
    server.send(200, "text/html", html);
}

void handleSaveRpmConfig() {
    if (!isAuthorized()) return server.requestAuthentication();

    String action = server.arg(F("action"));
    
    // Daten auslesen und validieren
    int pulses = server.arg(F("pulses")).toInt();
    int offset = server.arg(F("offset")).toInt();
    float tdc = server.arg(F("tdc")).toFloat();
    bool is_digital = server.arg(F("is_digital")).toInt() == 1;

    // NEU: Spulendaten auslesen
    float rp = server.arg(F("rp")).toFloat();
    float rext = server.arg(F("rext")).toFloat();
    float lp = server.arg(F("lp")).toFloat();
    float itarget = server.arg(F("itarget")).toFloat();
    float dwell = server.arg(F("dwell")).toFloat();


    if (pulses <= 0 || pulses > 20 || offset < 0 || offset > 360 || rp <= 0 || lp <= 0 || itarget <= 0 || dwell <= 0) {
         server.send(400, F("text/plain"), F("Fehler: Ung√ºltige Werte f√ºr RPM/Timing oder Spulenparameter."));
         return;
    }

    // On-the-Fly Update der globalen VOLATILE Variablen
    noInterrupts();
    rpmConfig.pulses_per_revolution = pulses;
    rpmConfig.is_digital = is_digital;
    timingConfig.trigger_offset_deg = offset;
    timingConfig.TDC_adjust_deg = tdc;

    // NEU: Z√ºndspulen Configs aktualisieren
    coilConfig.primary_resistance_ohm = rp;
    coilConfig.external_resistance_ohm = rext;
    coilConfig.primary_inductance_mH = lp;
    coilConfig.target_current_A = itarget;
    coilConfig.fixed_dwell_ms = dwell;
    
    interrupts();
    
    LOG(LOG_INFO, "RPM/Timing/Spule Config im RAM aktualisiert. Rp+Rext: %.1f Ohm", rp + rext);

    if (action == F("save_all")) {
        // Speichern der gesamten Config (WLAN, Map, RPM/Timing, Spule)
        if (saveConfig()) {
            server.send(200, F("text/plain"), F("Konfiguration gespeichert. Neustart..."));
            delay(1000);
            ESP.restart(); 
            return;
        } else {
            server.send(500, F("text/plain"), F("Fehler beim Speichern der Konfiguration."));
            return;
        }
    } 
    
    // apply_only oder Fallback: Auto-Refresh zur Konfigurationsseite
    String responseHtml = F("<html><head><meta http-equiv='refresh' content='2;url=/rpmconfig'></head><body><h1>Erfolg!</h1><p>Konfiguration im RAM angewendet. Seite wird in 2 Sekunden neu geladen.</p><p><a href='/rpmconfig'>Manuell fortfahren</a></p></body></html>");
    server.send(200, F("text/html"), responseHtml);
}


// =========================================================
// 7. SERVER ROUTEN & OTA 
// =========================================================

void setup_server_routes() {
    server.on(F("/"), handleRoot);
    server.on(F("/set"), handleSetAktor); 
    server.on(F("/config"), handleConfig);      
    server.on(F("/saveconfig"), handleSaveConfig); 
    server.on(F("/viewlog"), handleViewLog); 
    server.on(F("/clearlog"), handleClearLog); 
    
    server.on(F("/curve"), handleCurveConfig);
    server.on(F("/savecurve"), handleSaveCurve); 
    server.on(F("/restorecurve"), handleRestoreCurve); 

    // NEU: RPM/Timing Konfigurationsrouten
    server.on(F("/rpmconfig"), handleRpmConfig);
    server.on(F("/saverpmconfig"), handleSaveRpmConfig);
    
    LOG(LOG_INFO, "HTTP Routen konfiguriert.");
    serverStarted = true;
}

void setup_ota() {
  if (WiFi.status() != WL_CONNECTED) { return; }
  MDNS.begin(apSsid.c_str());
  ArduinoOTA.setHostname(apSsid.c_str());
  // Nutzt geladenes AP-Passwort
  ArduinoOTA.setPassword(apPassword.c_str()); 
  
  ArduinoOTA.onStart([]() { server.stop(); LOG(LOG_WARN, "OTA Update beginnt."); });
  ArduinoOTA.onEnd([]() { LOG(LOG_INFO, "OTA Update erfolgreich. Neustart."); });
  ArduinoOTA.onError([](ota_error_t error) { LOG(LOG_ERROR, "OTA Fehler: Code %d", error); }); 
  
  ArduinoOTA.begin();
  LOG(LOG_INFO, "OTA Service gestartet.");
}


// =========================================================
// 8. SETUP und LOOP
// =========================================================

void setup() {
  Serial.begin(115600); // Erh√∂hen der Baudrate f√ºr schnellere Logs
  delay(100);

  LOG(LOG_INFO, "üöÄ ESP8266 Z√ºndungssteuerung (RPM-Offset V2 - Final)");
  LOG(LOG_INFO, "Firmware: %s %s", __DATE__, __TIME__);
  
  // 1. Z√ºndungs-Core initialisieren
  pinMode(IGNITION_INPUT_PIN, INPUT_PULLUP);
  pinMode(IGNITION_OUTPUT_PIN, OUTPUT);
  digitalWrite(IGNITION_OUTPUT_PIN, LOW);

  timer1_disable(); 
  attachInterrupt(digitalPinToInterrupt(IGNITION_INPUT_PIN), handleIgnitionPulse, RISING);
  LOG(LOG_INFO, "‚úÖ Z√ºndungs-Core mit Pin D%d (Interrupt) initialisiert.", digitalPinToInterrupt(IGNITION_INPUT_PIN));

  // 2. Restliche Pins
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, HIGH);
  ledState = false;
  pinMode(BUTTON_PIN, INPUT_PULLUP);


  // 3. Initialisiere die schnellen, polymorphen Sensor-Tasks (Round-Robin-Konfiguration)
  allSensorTasks.reserve(5); 

  // --- HOHE RATE (20 Hz) ---
  allSensorTasks.push_back({
    std::make_unique<TPS_Sensor>(ADC_PIN, 50), // Pin A0, Intervall 50ms
    0, 
    SID_TPS_RAW
  });
  allSensorTasks.push_back({
    std::make_unique<Static_Sensor>(50.0f, 50), // Geschwindigkeit 20Hz
    0, 
    SID_SPEED
  });
  
  // --- MITTLERE/NIEDRIGE RATE (1 Hz / 1000ms) ---
  // Batteriespannung mit Kalibrierung (verwende CalibratedAnalog_Sensor)
  allSensorTasks.push_back({
    std::make_unique<CalibratedAnalog_Sensor>(3.3f, 11.0f, 1000), // 3.3V Ref, 11:1 Teiler, 1s Intervall
    0, 
    SID_BATT_V
  });
  
  allSensorTasks.push_back({
    std::make_unique<Static_Sensor>(85.5f, 1000), // Zylinderkopftemp
    0, 
    SID_TEMP_KOPF
  });
  allSensorTasks.push_back({
    std::make_unique<Static_Sensor>(22.0f, 1000), // Umgebungstemp
    0, 
    SID_TEMP_UMG
  });
  
  LOG(LOG_INFO, "‚úÖ %d Polymorphe Sensor Tasks initialisiert.", allSensorTasks.size());


  // 4. NEU: Initialisiere I2C Expander Tasks
  allExpanderTasks.reserve(4); 

  allExpanderTasks.push_back(std::make_unique<I2C_Expander>(0x20, 500)); 
  allExpanderTasks.push_back(std::make_unique<I2C_Expander>(0x38, 1000)); 
  allExpanderTasks.push_back(std::make_unique<I2C_Expander>(0x21, 500)); 
  
  LOG(LOG_INFO, "‚úÖ %d I2C Expander Controller initialisiert.", allExpanderTasks.size());


  WiFi.mode(WIFI_STA);
  WiFi.setSleepMode(WIFI_NONE_SLEEP); 

  if (!LittleFS.begin()) {
      LOG(LOG_ERROR, "LittleFS Start fehlgeschlagen.");
      startApMode = true;
      return;
  }

  // Lade Konfiguration (STA, AP, RPM, Timing, Map, Spule)
  if (!loadConfig()) {
      LOG(LOG_ERROR, "Kritischer Fehler beim Laden der Konfiguration. Starte mit AP.");
      startApMode = true;
  }

  // Boot-Log
  String bootMsg = F("BOOT_START;FW=") + String(__DATE__) + F(" ") + String(__TIME__);
  logCriticalEvent(0, 0, bootMsg.c_str());

  // WLAN-Verbindung
  LOG(LOG_INFO, "Verbinde mit: %s", wifiSsid.c_str());
  WiFi.begin(wifiSsid.c_str(), wifiPassword.c_str());

  unsigned long startTime = millis();
  const unsigned long TIMEOUT = 15000;
  while (WiFi.status() != WL_CONNECTED && (millis() - startTime < TIMEOUT)) {
      delay(100);
      ESP.wdtFeed(); 
  }

  if (WiFi.status() == WL_CONNECTED) {
      LOG(LOG_INFO, "‚úÖ Verbunden! IP: %s", WiFi.localIP().toString().c_str());
      boot_time_ms = millis();
      setup_server_routes(); 
      server.begin();
      setup_ota(); 
      advanceTicker.attach_ms(50, updateIgnitionParameters); // Aktualisiert Z√ºndparameter (20Hz)
      debugTicker.attach(1, printLoopStatus); // Loggt Status (1Hz)
      LOG(LOG_INFO, "System bereit. Heap: %d Bytes", ESP.getFreeHeap());
      return;
  }

  // Fallback: AP-Modus
  LOG(LOG_WARN, "Verbindung fehlgeschlagen. Starte AP-Modus.");
  startApMode = true;
}

void loop() {
    ESP.wdtFeed();

    unsigned long start_loop_micros = micros();
    unsigned long now = millis();

    // 1. AP-Modus Handling
    if (startApMode) {
        if (WiFi.getMode() != WIFI_AP) {
            LOG(LOG_INFO, "Starte Konfigurations-AP...");
            WiFi.mode(WIFI_AP);
            // Nutze geladene AP-SSID/Passwort
            WiFi.softAP(apSsid.c_str(), apPassword.c_str()); 
            LOG(LOG_INFO, "AP IP: %s", WiFi.softAPIP().toString().c_str());
            setup_server_routes();
            server.begin();
        }
        server.handleClient();

        if (now - lastHeapCheck >= HEAP_CHECK_INTERVAL) {
            checkHeapHealth();
            lastHeapCheck = now;
        }

        if (now - lastOtaHandle >= OTA_HANDLE_INTERVAL) {
            ArduinoOTA.handle();
            lastOtaHandle = now;
        }

        unsigned long duration = micros() - start_loop_micros;
        loop_durations_buffer[stats_index] = duration;
        stats_index = (stats_index + 1) % STATS_WINDOW_SIZE;
        calculateLoopStatistics();
        return; 
    }

    // 2. STA-Modus Handling
    if (WiFi.status() == WL_CONNECTED) {
        bool server_allowed = (now >= (boot_time_ms + server_start_delay_ms));

        if (server_allowed) {
            if (now - lastWebHandle >= WEB_HANDLE_INTERVAL) {
                server.handleClient();
                lastWebHandle = now;
            }
            if (now - lastOtaHandle >= OTA_HANDLE_INTERVAL) {
                ArduinoOTA.handle();
                lastOtaHandle = now;
            }
        }

        if (now - lastHeapCheck >= HEAP_CHECK_INTERVAL) {
            checkHeapHealth();
            lastHeapCheck = now;
        }
    }

    // Loop-Dauer messen und Statistik aktualisieren
    unsigned long current_duration = micros() - start_loop_micros;
    loop_durations_buffer[stats_index] = current_duration;
    stats_index = (stats_index + 1) % STATS_WINDOW_SIZE;
    
    if (++calc_counter >= CALC_FREQUENCY) {
        calculateLoopStatistics();
        calc_counter = 0;
    }
}