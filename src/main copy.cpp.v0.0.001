#include <Arduino.h>
#include <ESP8266WiFi.h>
#include <ESP8266WebServer.h>
#include <LittleFS.h>      
#include <ArduinoJson.h>   
#include <ESP.h>           
#include "secrets.h"       
#include <Ticker.h>             
#include <memory>
#include <vector>
#include <stdarg.h> 
#include <algorithm> 
#include <cmath> 
#include <ArduinoOTA.h>    
#include <ESP8266mDNS.h>   
#include <functional> 

extern "C" {
  #include "user_interface.h"
}

#pragma GCC optimize ("O3")

// =========================================================
// 1. GLOBALE DEFS UND LOGGER
// =========================================================

// --- GLOBALE LOG-LEVELS ---
enum LogLevel { LOG_DEBUG, LOG_INFO, LOG_WARN, LOG_ERROR };
// Forward Deklaration des Loggers
void app_log(LogLevel level, const char* file, int line, int logLine, const char* format, ...);
// Das Makro verwendet die Zeilennummer, auf der das Makro aufgerufen wird
#define LOG(level, format, ...) app_log(level, __FILE__, __LINE__, __LINE__, format, ##__VA_ARGS__) 

// --- ZUS√ÑTZLICHE IN-RAM LOGGING STRUKTUR F√úR STARTPHASE ---
std::vector<String> startupLogBuffer;
const size_t MAX_STARTUP_LOGS = 50; 

// --- WICHTIGE GLOBALE STATUSVARIABLEN (VOR app_log DEKLARIERT) ---
bool serverStarted = false;     // Wichtig f√ºr die Log-Pufferung
bool startApMode = false;       
volatile LogLevel activeLogLevel = LOG_DEBUG; // ZENTRALE VARIABLE F√úR DEN AKTIVEN LOG-LEVEL

// ZENTRALER LOGGER DEFINITION (MIT LEVEL-PR√úFUNG)
void app_log(LogLevel level, const char* file, int line, int logLine, const char* format, ...) {
    // PR√úFUNG VOR DER AUSGABE
    if (level < activeLogLevel) return; 

    const char* levelStr = "UNKNOWN";
    switch (level) {
        case LOG_DEBUG: levelStr = "DEBUG"; break;
        case LOG_INFO:  levelStr = "INFO";  break;
        case LOG_WARN:  levelStr = "WARNUNG"; break;
        case LOG_ERROR: levelStr = "FEHLER"; break;
    }
    
    unsigned long timeMs = millis();
    char logBuffer[256];
    
    int len = snprintf(logBuffer, sizeof(logBuffer), "[%lu ms] [%s] (%s:%d) ", 
                       timeMs, levelStr, file, logLine);

    va_list args;
    va_start(args, format);
    vsnprintf(logBuffer + len, sizeof(logBuffer) - len, format, args);
    va_end(args);
    
    Serial.println(logBuffer);
    
    // Log-Pufferung f√ºr kritische Startphase
    if (!serverStarted && startupLogBuffer.size() < MAX_STARTUP_LOGS) {
        startupLogBuffer.push_back(String(logBuffer)); 
    }
}

// --- Z√úNDUNGSKONFIGURATION ---
const int IGNITION_INPUT_PIN = D1;  
const int IGNITION_OUTPUT_PIN = D2; 
const int ADC_PIN = A0; // Dedizierter Pin f√ºr Hall/TPS Sensor
const int SPEED_INPUT_PIN = D0; // Geschwindigkeitssensor

// PIN PLATZHALTER (f√ºr digitale Eing√§nge)
const int PIN_LIGHT_IN    = D5; 
const int PIN_FARLIGHT_IN = D6; 
const int PIN_BRAKE_IN    = D7;
const int PIN_BLINK_LEFT  = D4; 
const int PIN_BLINK_RIGHT = D3; 

// --- RPM Konfiguration (Wird aus JSON geladen)
struct RpmConfig {
    volatile int pulses_per_revolution; 
    volatile bool is_digital; 
    volatile int input_pin;
} rpmConfig = {1, true, IGNITION_INPUT_PIN}; 

// --- Z√ºndungs-Timing Konfiguration (Wird aus JSON geladen) ---
struct IgnitionTimingConfig {
    volatile int trigger_offset_deg; 
    volatile float TDC_adjust_deg;  
} timingConfig = {60, 0.0f}; 

// --- NEU: Z√ºndspulen-Konfiguration (Wird aus JSON geladen) ---
struct IgnitionCoilConfig {
    volatile float primary_resistance_ohm;  
    volatile float external_resistance_ohm; 
    volatile float primary_inductance_mH;   
    volatile float target_current_A;        
    volatile float fixed_dwell_ms;          
} coilConfig = {0.2f, 2.0f, 4.0f, 8.0f, 3.5f}; 


// --- ZENTRALE DATENSTRUKTUREN ---
struct IgnitionState {
    volatile unsigned long last_pulse_micros;
    volatile unsigned long period_micros;
    volatile int rpm;
    volatile unsigned long advance_micros;
    volatile bool pulse_detected;
} ignition = {0, 0, 0, 0, false};

struct SpeedState {
    volatile unsigned long last_pulse_micros;
    volatile unsigned long period_micros;
    volatile float speed_kmh_raw;
} speedState = {0, 0, 0.0f};

// Zentrale Struktur f√ºr alle Sensor-Inputs
struct SensorState {
    volatile int tps_raw;               
    volatile int geschwindigkeit_kmh;    
    volatile bool licht_ein_state;      
    volatile bool fernlicht_ein_state;  
    volatile bool bremslicht_state;     
    volatile bool blinker_links_state;  
    volatile bool blinker_rechts_state; 
    volatile float batteriespannung_v;       
    volatile float temperatur_zylinderkopf_c; 
    volatile float temperatur_luftfilterkasten_c; 
    volatile float temperatur_umgebung_c;    
    volatile float luftfeuchtigkeit_umgebung_pct; 
} sensor = {0, 0, false, false, false, false, false, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f};

struct MapPoint { int rpm; int tps; int angle; };
std::vector<MapPoint> ignitionMap;


// --- SENSOR ABSTRAKTION UND VERWALTUNG ---
enum SensorID { SID_TPS_RAW, SID_SPEED, SID_BATT_V, SID_TEMP_KOPF, SID_TEMP_LUFT, SID_TEMP_UMG, SID_FEUCHTIGKEIT, SID_LIGHT, SID_FARLIGHT, SID_BRAKE, SID_BLINK_L, SID_BLINK_R, SID_COUNT };

class BaseSensor { public: virtual ~BaseSensor() {} virtual float readValue() = 0; virtual unsigned long getMinInterval() = 0; };
class TPS_Sensor : public BaseSensor { private: const int _pin; const unsigned long _interval; public: TPS_Sensor(int pin, unsigned long interval_ms) : _pin(pin), _interval(interval_ms) {} unsigned long getMinInterval() override { return _interval; } float readValue() override { return (float)analogRead(_pin); } };
class DigitalInput_Sensor : public BaseSensor { private: const int _pin; const unsigned long _interval; const bool _pullup; public: DigitalInput_Sensor(int pin, unsigned long interval_ms, bool pullup = true) : _pin(pin), _interval(interval_ms), _pullup(pullup) { pinMode(_pin, _pullup ? INPUT_PULLUP : INPUT); } unsigned long getMinInterval() override { return _interval; } float readValue() override { return (digitalRead(_pin) == (_pullup ? LOW : HIGH)) ? 1.0f : 0.0f; } };
class Static_Sensor : public BaseSensor { private: const float _value; const unsigned long _interval; public: Static_Sensor(float value, unsigned long interval_ms) : _value(value), _interval(interval_ms) {} unsigned long getMinInterval() override { return _interval; } float readValue() override { return _value; } };
class CalibratedAnalog_Sensor : public BaseSensor { private: const float _adc_ref; const float _divider_ratio; const unsigned long _interval; public: CalibratedAnalog_Sensor(float adc_ref, float divider_ratio, unsigned long interval_ms) : _adc_ref(adc_ref), _divider_ratio(divider_ratio), _interval(interval_ms) {} unsigned long getMinInterval() override { return _interval; } float readRawADC() { return 350.0f; } float readValue() override { float v_adc = readRawADC() * (_adc_ref / 1023.0f); return v_adc * _divider_ratio; } };
class TempSensorSim : public BaseSensor { private: const unsigned long _interval; public: TempSensorSim(unsigned long interval_ms) : _interval(interval_ms) {} unsigned long getMinInterval() override { return _interval; } float readValue() override { return 25.0f + (sin((float)millis() / 5000.0f) * 5.0f); } }; 
class I2C_Expander { private: uint8_t _address; const unsigned long _interval; public: unsigned long last_update_ms = 0; I2C_Expander(uint8_t address, unsigned long interval_ms) : _address(address), _interval(interval_ms) { LOG(LOG_INFO, "Expander 0x%X initialisiert.", _address); } unsigned long getMinInterval() const { return _interval; } uint16_t readPort() { return 0b1010101010101010; } void execute() { uint16_t port_value = readPort(); if (_address == 0x20) { noInterrupts(); sensor.blinker_links_state = (port_value & 0x0001); sensor.blinker_rechts_state = (port_value & 0x0002); interrupts(); } LOG(LOG_DEBUG, "Expander 0x%X I/O gelesen. (Port: 0x%X)", _address, port_value); } };

struct SensorTask { std::unique_ptr<BaseSensor> sensor_ptr; unsigned long last_update_ms = 0; SensorID target_id; };
std::vector<SensorTask> allSensorTasks;
static int current_task_index = 0;
std::vector<std::unique_ptr<I2C_Expander>> allExpanderTasks;


// --- STATISTIK & RESSOURCEN ---
const int STATS_WINDOW_SIZE = 100; 
const unsigned long MAX_LOOP_DURATION_US = 10000;
const char *LOG_FILENAME = "/critical_log.txt";
const int MAX_LOG_LINES = 100;
const unsigned long MIN_HEAP_WARNING = 5000;

volatile unsigned long loop_durations_buffer[STATS_WINDOW_SIZE];
volatile int stats_index = 0;
volatile unsigned long max_loop_duration_us = 0;
volatile unsigned long min_loop_duration_us = 999999;
volatile unsigned long avg_loop_duration_us = 0;
volatile unsigned long last_critical_max_duration_us = 0;
volatile unsigned long last_critical_timestamp_ms = 0;
volatile bool is_critical_latency_active = false;

// --- Zeitbasiertes Web-Handling ---
unsigned long lastWebHandle = 0;
unsigned long lastOtaHandle = 0;
unsigned long lastHeapCheck = 0;
const unsigned long WEB_HANDLE_INTERVAL = 200;
const unsigned long OTA_HANDLE_INTERVAL = 1000; 
const unsigned long HEAP_CHECK_INTERVAL = 5000;

volatile unsigned long server_start_delay_ms = 30000;
volatile unsigned long boot_time_ms = 0;
static int calc_counter = 0;
const int CALC_FREQUENCY = 100;


// --- NOTFALL-FALLBACK KENNFIELD (PROGMEM) ---
const char* FALLBACK_CURVE_JSON = R"({"ssid": "", "password": "", "ap_ssid": "esp-aktor", "ap_password": "MeinSicheresPasswort", "rpm_pulses": 1, "rpm_type": true, "timing_offset": 60, "timing_tdc": 0.0, "primary_resistance_ohm": 0.2, "external_resistance_ohm": 2.0, "primary_inductance_mH": 4.0, "target_current_A": 8.0, "fixed_dwell_ms": 3.5, "log_level": 0, "map": [ {"rpm": 0, "tps": 0, "angle": 10}, {"rpm": 8000, "tps": 1023, "angle": 8} ]})"; 


// Ticker-Instanzen
Ticker advanceTicker;
Ticker debugTicker; 

// --- ANDERE KONFIGURATION ---
const int LED_PIN = D4;     
const int BUTTON_PIN = D5;  
const char* HTTP_USERNAME = "admin"; 

// Globale Variablen f√ºr STA und AP Konfiguration
String wifiSsid = ""; 
String wifiPassword = "";
String apSsid = "esp-aktor"; 
String apPassword = "MeinSicheresPasswort"; 

ESP8266WebServer server(80);

// =========================================================
// 2. FORWARD-DEKLARATIONEN DER HAUPTFUNKTIONEN
// =========================================================

void logCriticalEvent(unsigned long maxDuration, unsigned long timestamp, const char* status); 
bool loadConfig();
bool saveConfig();
bool isAuthorized(); 
int pinNameToCode(String pinName); 
void setPinState(int pinCode, bool targetState); 
void calculateLoopStatistics();
void trimLogFile();
void checkHeapHealth();
bool loadDataFromJson(const char* jsonString); 
int getAdvanceAngle2D(int rpm, int tps);
void updateIgnitionParameters();
void updateSensorState(SensorID id, float value); 
void updateSensorsRoundRobin();
void updateSlowIOControllers(); 
void setup_server_routes(); 
void setup_ota(); 
void handleRoot(); 
void handleSetAktor(); 
void handleConfig(); 
void handleSaveConfig(); 
void handleViewLog(); 
void handleClearLog(); 
void handleCurveConfig(); 
void handleSaveCurve(); 
void handleRestoreCurve(); 
void handleRpmConfig();
void handleSaveRpmConfig();
void printLoopStatus(); 
void handleLogConfig();
void handleSaveLogConfig();

unsigned long getIgnitionPeriodSafe();
int getIgnitionRpmSafe();
unsigned long getAdvanceMicrosSafe();
float getSpeedStateSafe();

// =========================================================
// 3. FUNKTIONSDEFINITIONEN (Kernlogik & Helper-Funktionen)
// =========================================================

// Definition der kritischen Getter 
unsigned long getIgnitionPeriodSafe() { noInterrupts(); unsigned long period = ignition.period_micros; interrupts(); return period; }
int getIgnitionRpmSafe() { noInterrupts(); int rpm = ignition.rpm; interrupts(); return rpm; }
unsigned long getAdvanceMicrosSafe() { noInterrupts(); unsigned long advance = ignition.advance_micros; interrupts(); return advance; }
bool isAuthorized() { return server.authenticate(HTTP_USERNAME, apPassword.c_str()); }

float getSpeedStateSafe() {
    noInterrupts(); 
    unsigned long period = speedState.period_micros; 
    float calFactor = 1.0f; 
    interrupts();

    if (period > 1000000UL) return 0.0f;
    if (period == 0 || calFactor == 0.0f) return 0.0f;
    return calFactor / (float)period; 
}

// HINZUGEF√úGT: pinNameToCode Implementierung
int pinNameToCode(String pinName) {
    pinName.toUpperCase();
    
    if (pinName.length() != 2 || pinName[0] != 'D') {
        return -1;
    }
    
    switch (pinName[1]) {
        case '0': return D0;
        case '1': return D1;
        case '2': return D2;
        case '3': return D3;
        case '4': return D4;
        case '5': return D5;
        case '6': return D6;
        case '7': return D7;
        default: return -1;
    }
}

// HINZUGEF√úGT: setPinState Implementierung
void setPinState(int pinCode, bool targetState) { 
  if (pinCode == -1) return;

  if (pinCode == LED_PIN) {
      digitalWrite(pinCode, targetState ? LOW : HIGH); 
  } else {
      digitalWrite(pinCode, targetState ? HIGH : LOW);
  }
  LOG(LOG_DEBUG, "Pin %d -> %s", pinCode, targetState ? "HIGH" : "LOW");
}

int getAdvanceAngle2D(int rpm, int tps) {
    if (ignitionMap.empty()) return 0;
    
    std::vector<MapPoint> currentMap;
    noInterrupts();
    currentMap = ignitionMap;
    interrupts();
    
    if (currentMap.size() > 1) {
        std::sort(currentMap.begin(), currentMap.end(), [](const MapPoint& a, const MapPoint& b) {
             if (a.rpm != b.rpm) return a.rpm < b.rpm;
             return a.tps < b.tps;
           });
    }

    // [Implementierung der 2D-Interpolation]
    if (rpm > 5000) return 15;
    if (tps > 800) return 10;
    return 25; 
}

void IRAM_ATTR fireIgnitionOutput() {
    digitalWrite(IGNITION_OUTPUT_PIN, HIGH);
    delayMicroseconds(50); 
    digitalWrite(IGNITION_OUTPUT_PIN, LOW);
}

void IRAM_ATTR handleIgnitionPulse() {
    unsigned long current_micros = micros();

    if (ignition.last_pulse_micros != 0) {
        ignition.period_micros = current_micros - ignition.last_pulse_micros;

        if (ignition.period_micros > 1000) {
            if (rpmConfig.pulses_per_revolution > 0) {
                ignition.rpm = (60000000UL / ignition.period_micros) / rpmConfig.pulses_per_revolution;
            } else {
                ignition.rpm = 0;
            }
        }

        unsigned long required_advance = ignition.advance_micros;

        if (required_advance > 100 && required_advance < ignition.period_micros) {
            timer1_attachInterrupt(fireIgnitionOutput);
            timer1_enable(TIM_DIV1, TIM_EDGE, TIM_SINGLE);
            timer1_write(required_advance * 5);
        }
    }

    ignition.last_pulse_micros = current_micros;
    ignition.pulse_detected = true;
}

void IRAM_ATTR handleSpeedPulse() {
    unsigned long current_micros = micros();
    if (speedState.last_pulse_micros != 0) {
        speedState.period_micros = current_micros - speedState.last_pulse_micros;
    }
    speedState.last_pulse_micros = current_micros;
}


void updateSensorState(SensorID id, float value) {
    noInterrupts();
    switch(id) {
        case SID_TPS_RAW: sensor.tps_raw = (int)std::round(value); sensor.bremslicht_state = (sensor.tps_raw > 500); break;
        case SID_SPEED: sensor.geschwindigkeit_kmh = (int)std::round(value); break;
        case SID_BATT_V: sensor.batteriespannung_v = value; break; // <-- KORRIGIERT: Tippfehler behoben
        case SID_TEMP_KOPF: sensor.temperatur_zylinderkopf_c = value; break;
        case SID_TEMP_LUFT: sensor.temperatur_luftfilterkasten_c = value; break;
        case SID_TEMP_UMG: sensor.temperatur_umgebung_c = value; break;
        case SID_FEUCHTIGKEIT: sensor.luftfeuchtigkeit_umgebung_pct = value; break;
        case SID_LIGHT: sensor.licht_ein_state = (value > 0.5f); break;
        case SID_FARLIGHT: sensor.fernlicht_ein_state = (value > 0.5f); break;
        case SID_BLINK_L: sensor.blinker_links_state = (value > 0.5f); break;
        case SID_BLINK_R: sensor.blinker_rechts_state = (value > 0.5f); break;
        default: break;
    }
    interrupts();
}

void updateSensorsRoundRobin() {
    if (allSensorTasks.empty()) return;
    
    unsigned long current_time = millis();
    SensorTask& currentTask = allSensorTasks[current_task_index];

    if ((current_time - currentTask.last_update_ms) >= currentTask.sensor_ptr->getMinInterval()) {
        float value = currentTask.sensor_ptr->readValue(); 
        updateSensorState(currentTask.target_id, value);
        currentTask.last_update_ms = current_time; 
    }
    current_task_index = (current_task_index + 1) % allSensorTasks.size();
}

void updateSlowIOControllers() {
    if (allExpanderTasks.empty()) return;
    unsigned long current_time = millis();
    
    for (auto& expander : allExpanderTasks) {
        if ((current_time - expander->last_update_ms) >= expander->getMinInterval()) {
            expander->execute(); 
            expander->last_update_ms = current_time;
        }
    }
}

void updateIgnitionParameters() {
    // 1. I/O Updates (Laufen im Ticker)
    updateSensorsRoundRobin();  
    updateSlowIOControllers();  

    int rpm_copy = getIgnitionRpmSafe();
    unsigned long period = getIgnitionPeriodSafe();
    
    int tps_value;
    noInterrupts(); tps_value = sensor.tps_raw; interrupts();

    int advance_angle = getAdvanceAngle2D(rpm_copy, tps_value);  
    
    // --- Dwell-Berechnung (Erweiterte Konfiguration) ---
    float Dwell_ms_calc;
    float fixed_dwell; 
    noInterrupts();
    float R_total = coilConfig.primary_resistance_ohm + coilConfig.external_resistance_ohm;
    float L_mH = coilConfig.primary_inductance_mH;
    fixed_dwell = coilConfig.fixed_dwell_ms;
    interrupts();

    if (R_total > 0.1f) { Dwell_ms_calc = L_mH / R_total; } else { Dwell_ms_calc = fixed_dwell; }
    unsigned long Dwell_micros = (unsigned long)(std::max(Dwell_ms_calc, fixed_dwell) * 1000.0f);
    
    // --- Advance-Berechnung ---
    if (period > 1000) {
        float time_per_degree_micros = (float)period / 360.0f;
        unsigned long advance_time_micros = (unsigned long)(advance_angle * time_per_degree_micros);
        unsigned long total_advance_micros = advance_time_micros + Dwell_micros; // Z√ºndpunkt + Ladezeit
        
        noInterrupts();
        ignition.advance_micros = total_advance_micros;
        interrupts();
    } else {
        noInterrupts();
        ignition.advance_micros = 0;
        interrupts();
    }
}


// =========================================================
// 4. STATISTIK & LOGGING-LOGIK 
// =========================================================

void trimLogFile() {
    if (!LittleFS.begin()) return;
    File logFile = LittleFS.open(LOG_FILENAME, "r");
    if (!logFile) return;

    // [Implementierung des Log-Trim-Vorgangs]
}

void logCriticalEvent(unsigned long maxDuration, unsigned long timestamp, const char* status) {
    if (!LittleFS.begin()) { LOG(LOG_ERROR, "LittleFS nicht verf√ºgbar f√ºr Logging."); return; }
    File logFile = LittleFS.open(LOG_FILENAME, "a");
    if (!logFile) { LOG(LOG_ERROR, "Fehler beim √ñffnen der Logdatei zum Schreiben."); return; }

    String logEntry = String(status);
    logEntry += F(";MAX="); logEntry += String(maxDuration);
    logEntry += F(";TIME_MS="); logEntry += String(timestamp);

    logFile.println(logEntry); 
    logFile.close();
    LOG(LOG_WARN, "Kritischer Eintrag gespeichert: %s", logEntry.c_str());
}

void calculateLoopStatistics() {
    if (++calc_counter < CALC_FREQUENCY) return;
    calc_counter = 0;

    unsigned long sum = 0;
    unsigned long current_max = 0;
    unsigned long current_min = 999999;
    
    for (int i = 0; i < STATS_WINDOW_SIZE; i++) {
        unsigned long value = loop_durations_buffer[i];
        sum += value;
        current_max = std::max(current_max, value);
        if (value > 0) current_min = std::min(current_min, value);
    }
    
    avg_loop_duration_us = sum / STATS_WINDOW_SIZE;
    max_loop_duration_us = current_max;
    min_loop_duration_us = current_min;
}

void checkHeapHealth() {
    uint32_t freeHeap = ESP.getFreeHeap();
    if (freeHeap < MIN_HEAP_WARNING) { LOG(LOG_WARN, "‚ö†Ô∏è Heap niedrig: %d Bytes frei!", freeHeap); }
    if (freeHeap < 2000) { LOG(LOG_ERROR, "üö® KRITISCH: Nur noch %d Bytes Heap! Neustart empfohlen.", freeHeap); }
}

void printLoopStatus() {
    calculateLoopStatistics(); 
    
    int rpm = getIgnitionRpmSafe();
    unsigned long advance = getAdvanceMicrosSafe();
    
    int tps_raw;
    float temp_kopf, batt_v;
    noInterrupts();
    tps_raw = sensor.tps_raw;
    temp_kopf = sensor.temperatur_zylinderkopf_c;
    batt_v = sensor.batteriespannung_v;
    interrupts();
    
    LOG(LOG_DEBUG, "RPM:%d | TPS:%d | ADV:%lu¬µs | L(MAX:%lu/AVG:%lu)¬µs | CHT:%.1f¬∞C | BAT:%.1fV | Heap:%d", 
        rpm, tps_raw, advance, 
        max_loop_duration_us, avg_loop_duration_us, 
        temp_kopf, batt_v, ESP.getFreeHeap());
    
    if (max_loop_duration_us > MAX_LOOP_DURATION_US && !is_critical_latency_active) {
         is_critical_latency_active = true;
         last_critical_max_duration_us = max_loop_duration_us;
         last_critical_timestamp_ms = millis();
         logCriticalEvent(last_critical_max_duration_us, last_critical_timestamp_ms, "CRITICAL_LATENCY");
         LOG(LOG_WARN, "Latenz kritisch! Max: %lu ¬µs", max_loop_duration_us);
    } else if (max_loop_duration_us <= MAX_LOOP_DURATION_US && is_critical_latency_active) {
         is_critical_latency_active = false;
    }
}


// =========================================================
// 5. KONFIGURATION UND HANDLER (WLAN-Persistenz & Debug)
// =========================================================

void updateSpeedCalibrationFactor() {
    noInterrupts();
    // Beispiel: speedCalConfig.calibration_factor = (3600.0f * (float)speedCalConfig.wheel_circumference_mm) / (float)speedCalConfig.sprocket_teeth;
    interrupts();
}

bool loadDataFromJson(const char* jsonString) { 
    StaticJsonDocument<2048> doc; DeserializationError error = deserializeJson(doc, jsonString);
    
    // WICHTIG: Pr√ºfe den JSON Fehlercode!
    if (error) { 
        LOG(LOG_ERROR, "JSON Fehlercode: %s", error.c_str()); 
        return false; 
    } 
    
    // L√ÑDT WLAN UND KONFIGURATION
    wifiSsid = doc[F("ssid")].as<String>();
    wifiPassword = doc[F("password")] | "";
    apSsid = doc[F("ap_ssid")] | "esp-aktor";
    apPassword = doc[F("ap_password")] | "MeinSicheresPasswort";
    
    // Log-Level aus Konfigurationsdatei laden
    int levelInt = doc[F("log_level")] | LOG_DEBUG;
    activeLogLevel = (LogLevel)levelInt;
    
    rpmConfig.pulses_per_revolution = doc[F("rpm_pulses")] | 1;
    timingConfig.trigger_offset_deg = doc[F("timing_offset")] | 60; 
    coilConfig.primary_resistance_ohm = doc[F("primary_resistance_ohm")] | 0.2f;
    coilConfig.external_resistance_ohm = doc[F("external_resistance_ohm")] | 2.0f;
    
    // === DEBUG AUSGABE DER GELADENEN WERTE ===
    LOG(LOG_DEBUG, "--- GELADENE KONFIGURATION ---");
    LOG(LOG_DEBUG, "STA SSID: %s (L√§nge: %d)", wifiSsid.c_str(), wifiSsid.length());
    LOG(LOG_DEBUG, "STA PW L√§nge: %d", wifiPassword.length()); // Passwort selbst nicht loggen!
    LOG(LOG_DEBUG, "AP SSID: %s | AP PW L√§nge: %d", apSsid.c_str(), apPassword.length());
    LOG(LOG_DEBUG, "Log Level: %d", (int)activeLogLevel);
    LOG(LOG_DEBUG, "RPM Pulses: %d | Offset: %d deg", rpmConfig.pulses_per_revolution, timingConfig.trigger_offset_deg);
    
    // MAP LADEN
    JsonArray mapArray = doc[F("map")].as<JsonArray>(); 
    ignitionMap.clear();

    for (JsonObject point : mapArray) {
        if (point.containsKey(F("rpm")) && point.containsKey(F("tps")) && point.containsKey(F("angle"))) {
            ignitionMap.push_back({point[F("rpm")], point[F("tps")], point[F("angle")]});
        }
    }
    
    LOG(LOG_DEBUG, "Kennfeldpunkte geladen: %d", ignitionMap.size());

    if (ignitionMap.size() > 1) {
        std::sort(ignitionMap.begin(), ignitionMap.end(), [](const MapPoint& a, const MapPoint& b) {
            if (a.rpm != b.rpm) return a.rpm < b.rpm;
            return a.tps < b.tps;
        });
    }
    
    updateSpeedCalibrationFactor();
    return true;
}

bool loadConfig() { 
    File configFile = LittleFS.open(F("/config.json"), "r");
    if (configFile) {
        size_t size = configFile.size();
        std::unique_ptr<char[]> buf(new char[size + 1]);
        configFile.readBytes(buf.get(), size);
        buf.get()[size] = '\0';
        configFile.close();
        if (loadDataFromJson(buf.get())) { LOG(LOG_INFO, "Konfiguration aus Datei geladen."); return true; } 
        else { LOG(LOG_WARN, "Laden aus Datei fehlgeschlagen. Datei ist m√∂glicherweise korrupt."); }
    }
    if (loadDataFromJson(FALLBACK_CURVE_JSON)) { LOG(LOG_WARN, "Fallback-Kennfeld/Konfiguration geladen."); return true; } 
    return false;
}

bool saveConfig() { 
    StaticJsonDocument<2048> doc; 
    
    // SPEICHERN ALLER KONFIGURATIONEN
    doc[F("ssid")] = wifiSsid; doc[F("password")] = wifiPassword;
    doc[F("ap_ssid")] = apSsid; doc[F("ap_password")] = apPassword;
    doc[F("log_level")] = (int)activeLogLevel; // Log-Level speichern
    doc[F("rpm_pulses")] = rpmConfig.pulses_per_revolution;
    doc[F("timing_offset")] = timingConfig.trigger_offset_deg; 
    doc[F("primary_resistance_ohm")] = coilConfig.primary_resistance_ohm;
    doc[F("external_resistance_ohm")] = coilConfig.external_resistance_ohm;
    
    // MAP SPEICHERN
    JsonArray mapArray = doc.createNestedArray(F("map"));
    for (const auto& point : ignitionMap) {
        JsonObject obj = mapArray.createNestedObject();
        obj[F("rpm")] = point.rpm;
        obj[F("tps")] = point.tps;
        obj[F("angle")] = point.angle;
    }

    File configFile = LittleFS.open(F("/config.json"), "w");
    if (!configFile) return false;
    bool success = (serializeJson(doc, configFile) > 0);
    configFile.close();
    if (success) LOG(LOG_INFO, "Config gespeichert.");
    return true;
}

// =========================================================
// 6. SERVER HANDLER (Robuste Logik und UTF-8 Fix)
// =========================================================

void handleRoot() {
    if (!isAuthorized()) return server.requestAuthentication();
    
    int rpm = getIgnitionRpmSafe();
    int speed; float batt_v; float temp_kopf; int tps_raw;
    noInterrupts(); 
    speed = sensor.geschwindigkeit_kmh; batt_v = sensor.batteriespannung_v;
    temp_kopf = sensor.temperatur_zylinderkopf_c; tps_raw = sensor.tps_raw;
    interrupts();
    
    // UMFANGREICHES Dashboard HTML
    String html = F("<html><head><meta charset='UTF-8'><meta http-equiv='refresh' content='3'><title>ECU Dashboard</title></head><body>"); 
    html += F("<h1>üèçÔ∏è ECU Dashboard v1.2 (Version 0.0.100)</h1>");
    
    // KRITISCHE LATENZ WARNUNG
    if (is_critical_latency_active) {
        unsigned long seconds = last_critical_timestamp_ms / 1000;
        
        html += F("<div style='padding:10px;background:#ffcccc;border:2px solid red;margin-bottom:15px;'>");
        html += F("<h2>üö® KRITISCHE LATENZ IM LOOP ERKANNT!</h2>");
        html += F("<p><b>Gemessene Max. Dauer:</b> "); html += String(last_critical_max_duration_us); html += F(" ¬µs</p>");
        html += F("<p><b>Zeitstempel:</b> "); html += String(seconds); html += F(" s seit Boot</p>");
        html += F("<p>Bitte die <a href='/viewlog'>/viewlog Seite</a> pr√ºfen!</p>");
        html += F("</div>");
    }
    
    html += F("<h2>Echtzeit-Diagnose</h2><table border='1' cellpadding='5' style='min-width: 400px;'>");
    html += F("<tr><th colspan='2' style='background:#ccc;'>Motor & Performance</th></tr>");
    html += F("<tr><th>RPM (U/min)</th><td><b>"); html += String(rpm); html += F("</b></td></tr>");
    html += F("<tr><th>Geschw. (km/h)</th><td><b>"); html += String(speed); html += F("</b></td></tr>");
    html += F("<tr><th>TPS (Raw)</th><td>"); html += String(tps_raw); html += F("</td></tr>");
    html += F("<tr><th>Z√ºndwinkel (&deg; v.OT)</th><td>"); html += String(getAdvanceAngle2D(rpm, tps_raw)); html += F("</td></tr>");
    
    html += F("<tr><th colspan='2' style='background:#ccc;'>System & Sensoren</th></tr>");
    html += F("<tr><th>Batterie (V)</th><td><b>"); html += String(batt_v, 1); html += F(" V</b></td></tr>");
    html += F("<tr><th>Zylinderkopf (&deg;C)</th><td>"); html += String(temp_kopf, 1); html += F(" &deg;C</td></tr>");
    html += F("<tr><th>Gesamtwiderstand (&Omega;)</th><td><b>"); html += String(coilConfig.primary_resistance_ohm + coilConfig.external_resistance_ohm, 2); html += F("</b></td></tr>");
    html += F("</table>");

    html += F("<h2>ECU Status</h2>");
    html += F("<p>WLAN IP: <b>"); html += WiFi.status() == WL_CONNECTED ? WiFi.localIP().toString() : WiFi.softAPIP().toString(); html += F("</b></p>");
    html += F("<p>Free Heap: "); html += ESP.getFreeHeap(); html += F(" Bytes</p>");
    
    html += F("<p><a href='/rpmconfig'>‚öôÔ∏è Kalibrierung</a> | <a href='/curve'>üìà Z√ºndkurve</a> | <a href='/config'>üåê WLAN</a> | <a href='/viewlog'>üìú Logs</a> | <a href='/logconfig'>üéöÔ∏è Log-Level</a></p>");
    
    // NEU: Content-Type mit UTF-8 setzen
    server.send(200, "text/html; charset=utf-8", html);
}

void handleSetAktor() {
    if (!isAuthorized()) return server.requestAuthentication();
    if (!server.hasArg(F("pin")) || !server.hasArg(F("state"))) { server.send(400, "text/plain", F("Bad Request: pin und state erforderlich")); return; }
    int pinCode = pinNameToCode(server.arg(F("pin")));
    int state = server.arg(F("state")).toInt();
    setPinState(pinCode, state != 0);
    server.send(200, "text/plain", F("OK. Pin ") + server.arg(F("pin")) + F(" = ") + server.arg(F("state")));
}

void handleConfig() {
    if (!isAuthorized()) return server.requestAuthentication();

    String html = F("<html><head><meta charset='UTF-8'></head><body><h1>üåê WLAN Konfiguration</h1>");
    
    // Die aktuellen, aus dem RAM geladenen Werte werden in den Input-Feldern angezeigt.
    html += F("<h2>Client Mode (STA)</h2>");
    html += F("<form method='post' action='/saveconfig'>");
    html += F("STA SSID: <input type='text' name='ssid' maxlength='32' value='");
    html += wifiSsid; html += F("' required><br>");
    html += F("STA Passwort: <input type='password' name='password' minlength='8' value='");
    html += wifiPassword; html += F("' required><br><br>");
    
    html += F("<h2>Access Point Mode (AP - Fallback)</h2>");
    html += F("AP SSID (Hostname): <input type='text' name='ap_ssid' maxlength='32' value='");
    html += apSsid; html += F("' required><br>");
    html += F("AP Passwort: <input type='password' name='ap_password' minlength='8' value='");
    html += apPassword; html += F("' required><br><br>");
    
    html += F("<input type='submit' value='Speichern und Neustart' style='padding:10px;'>");
    html += F("</form><p><a href='/'>Zur√ºck zum Dashboard</a></p></body></html>");
    
    server.send(200, "text/html; charset=utf-8", html);
}

void handleSaveConfig() {
    if (!isAuthorized()) return server.requestAuthentication();

    // 1. NEUE WERTE AUS DEM FORMULAR AUSLESEN
    if (!server.hasArg(F("ssid")) || !server.hasArg(F("password")) || !server.hasArg(F("ap_ssid")) || !server.hasArg(F("ap_password"))) {
        server.send(400, "text/plain", F("Bad Request: Alle Felder erforderlich."));
        return;
    }
    
    String newSsid = server.arg(F("ssid"));
    String newPass = server.arg(F("password"));
    String newApSsid = server.arg(F("ap_ssid"));
    String newApPass = server.arg(F("ap_password"));
    
    // 2. VALIDIERUNG (Mindestl√§nge des STA-Passworts)
    if (newPass.length() < 8) {
         server.send(400, "text/plain", F("Fehler: STA Passwort muss mindestens 8 Zeichen haben."));
         return;
    }

    // 3. GLOBALE VARIABLEN AKTUALISIEREN (mit sicherer Interrupt-Behandlung)
    noInterrupts();
    wifiSsid = newSsid;
    wifiPassword = newPass;
    apSsid = newApSsid;
    apPassword = newApPass;
    interrupts();

    // 4. SPEICHERN und NEUSTART
    if (saveConfig()) { 
        LOG(LOG_INFO, "WLAN Config gespeichert. Neustart wird durchgef√ºhrt.");
        server.send(200, F("text/plain"), F("Gespeichert. Neustart...")); 
        ESP.restart(); 
    } 
    else { 
        LOG(LOG_ERROR, "Speichern der WLAN-Config fehlgeschlagen.");
        server.send(500, F("text/plain"), F("Fehler beim Speichern.")); 
    }
}

void handleViewLog() {
    if (!isAuthorized()) return server.requestAuthentication();

    String content = F("<html><head><meta charset='UTF-8'></head><body><h1>Kritische Latenz-Ereignisse (RAM & Flash)</h1><pre>");
    
    // Zuerst den RAM-Puffer ausgeben
    content += F("--- START-LOGS (IN-RAM BUFFER) ---\n");
    for (const String& logEntry : startupLogBuffer) {
        content += logEntry;
        content += "\n";
    }
    content += F("--- ENDE START-LOGS ---\n\n");
    
    
    content += F("--- KRITISCHE LOGS (LITTLEFS FLASH) ---\n");
    File logFile = LittleFS.open(LOG_FILENAME, "r");
    if (logFile) {
        content += logFile.readString(); 
        logFile.close();
    } else { 
        content += F("FLASH-Logdatei ist leer oder nicht vorhanden.\n");
    }
    content += F("--- ENDE FLASH-LOGS ---\n");


    content += F("</pre><p><a href='/'>Zur√ºck</a> | <a href='/clearlog'>L√∂schen des FLASH Logs</a></p></body></html>");
    server.send(200, "text/html; charset=utf-8", content);
}

void handleClearLog() {
    if (!isAuthorized()) return server.requestAuthentication();
    
    bool finalSuccess = false;

    // 1. VERSUCH: Datei entfernen
    if (LittleFS.remove(LOG_FILENAME)) { 
        LOG(LOG_INFO, "Logdatei erfolgreich entfernt."); 
        
        // 2. WIEDERHERSTELLUNG: Datei sofort neu erstellen, um Zuk√ºnftige Fehler bei remove() zu vermeiden.
        // Das √ñffnen im Modus "w" erstellt die Datei neu und l√§sst sie leer.
        File logFile = LittleFS.open(LOG_FILENAME, "w");
        if (logFile) {
            logFile.close();
            LOG(LOG_INFO, "Logdatei erfolgreich neu erstellt.");
            finalSuccess = true;
        } else {
            // Das Entfernen war erfolgreich, aber das Neuanlegen ist fehlgeschlagen.
            LOG(LOG_ERROR, "Logdatei entfernt, aber Neuanlage von %s fehlgeschlagen.", LOG_FILENAME);
            finalSuccess = false; 
        }
    } else {
        // 3. FALLBACK: Entfernen fehlgeschlagen (wahrscheinlich, weil die Datei nicht da war oder ein Lock hatte).
        // Wir versuchen, sie zu √∂ffnen und zu leeren, um sie wieder in einen definierten, leeren Zustand zu bringen.
        LOG(LOG_WARN, "LittleFS.remove() fehlgeschlagen. Versuche, die Datei zu leeren und neu zu erstellen...");
        File logFile = LittleFS.open(LOG_FILENAME, "w"); // √ñffnen mit "w" erstellt/k√ºrzt das File
        
        if (logFile) {
            logFile.close(); 
            LOG(LOG_INFO, "Log-Datei erfolgreich auf 0 Byte gek√ºrzt/neu erstellt.");
            finalSuccess = true;
        } else {
            // Kritischer Fehler - Weder entfernen noch √∂ffnen/k√ºrzen m√∂glich.
            LOG(LOG_ERROR, "Kritischer Fehler: Konnte %s weder entfernen noch k√ºrzen/neu erstellen.", LOG_FILENAME);
            finalSuccess = false; 
        }
    }

    // HTTP-Antwort mit UTF-8 Fix senden
    if (finalSuccess) {
        String html = F("<html><head><meta charset='UTF-8'></head><body><h1>‚úÖ Erfolg!</h1><p>Logdatei gel√∂scht/geleert und neu erstellt.</p><p><a href='/viewlog'>Zur√ºck zu Logs</a></p></body></html>");
        server.send(200, "text/html; charset=utf-8", html);
    } else {
        String html = F("<html><head><meta charset='UTF-8'></head><body><h1>‚ùå Fehler!</h1><p>L√∂schen/K√ºrzen fehlgeschlagen (Pr√ºfen Sie Serial Monitor).</p><p><a href='/viewlog'>Zur√ºck zu Logs</a></p></body></html>");
        server.send(500, "text/html; charset=utf-8", html);
    }
}

void handleCurveConfig() {
    if (!isAuthorized()) return server.requestAuthentication();

    String html = F("<html><head><meta charset='UTF-8'><title>Z√ºndkurven-Konfiguration</title></head><body>");
    html += F("<h1>üìà Z√ºndkurven-Konfiguration</h1>");
    html += F("<p>Hier k√∂nnen Sie die Z√ºndkennfeld-Punkte bearbeiten. √Ñnderungen werden erst nach 'Speichern & Neustart' permanent.</p>");
    html += F("<form method='post' action='/savecurve'>");

    // --- TABELLE START ---
    html += F("<table border='1' cellpadding='5'>");
    html += F("<tr><th>#</th><th>Drehzahl (RPM)</th><th>TPS (0-1023)</th><th>Winkel (¬∞ v. OT)</th><th>Aktion</th></tr>");

    std::vector<MapPoint> currentMap;
    noInterrupts();
    currentMap = ignitionMap;
    interrupts();
    
    // Sicherstellen, dass die Map sortiert ist (f√ºr Interpolation)
    if (currentMap.size() > 1) {
        std::sort(currentMap.begin(), currentMap.end(), [](const MapPoint& a, const MapPoint& b) {
            if (a.rpm != b.rpm) return a.rpm < b.rpm;
            return a.tps < b.tps;
        });
    }

    // --- EXISTIERENDE PUNKTE AUSGEBEN ---
    for (size_t i = 0; i < currentMap.size(); ++i) {
        String idx = String(i);
        
        html += F("<tr><td>"); html += idx; html += F("</td>");
        
        // RPM Input
        html += F("<td><input type='number' name='rpm_"); html += idx;
        html += F("' value='");
        html += String(currentMap[i].rpm); html += F("' min='0' required></td>");

        // TPS Input
        html += F("<td><input type='number' name='tps_"); html += idx;
        html += F("' value='");
        html += String(currentMap[i].tps); html += F("' min='0' max='1023' required></td>");

        // Angle Input
        html += F("<td><input type='number' name='angle_");
        html += idx; html += F("' value='");
        html += String(currentMap[i].angle); html += F("' min='-20' max='30' required></td>");

        // L√∂schen Button
        html += F("<td><button type='submit' name='delete_idx' value='"); html += idx;
        html += F("'>L√∂schen</button></td></tr>");
    }

    // --- NEUEN EINTRAG HINZUF√úGEN ---
    String new_idx = String(currentMap.size());
    html += F("<tr><td>"); html += new_idx; html += F(" (Neu)</td>");
    html += F("<td><input type='number' name='rpm_"); html += new_idx;
    html += F("' value='' min='0' placeholder='RPM' ></td>");
    html += F("<td><input type='number' name='tps_"); html += new_idx;
    html += F("' value='' min='0' max='1023' placeholder='TPS' ></td>");
    html += F("<td><input type='number' name='angle_"); html += new_idx;
    html += F("' value='' min='-20' max='30' placeholder='Winkel' ></td>");
    html += F("<td></td></tr>"); 
    
    html += F("</table>");
    // --- TABELLE ENDE ---

    html += F("<br><h2>Aktionen</h2>");
    
    html += F("<button type='submit' name='action' value='apply_only' style='background: #ffcc00;'>üß™ Im RAM Anwenden (Test)</button> ");
    html += F("<button type='submit' name='action' value='save_all'>‚úÖ Speichern auf Flash & Neustart</button>");
    
    html += F("</form>"); 

    html += F("<h2>Werkseinstellungen</h2>");
    html += F("<p>Stellt die Z√ºndkurve auf den unver√§nderlichen Firmware-Standard zur√ºck und startet neu.</p>");
    html += F("<form method='post' action='/restorecurve'>");
    html += F("<button type='submit'>‚ö†Ô∏è Standard-Kurve Wiederherstellen</button>");
    html += F("</form>");

    html += F("<p><a href='/'>Zur√ºck zum Dashboard</a></p></body></html>");
    
    server.send(200, "text/html; charset=utf-8", html);
}

void handleSaveCurve() {
    if (!isAuthorized()) return server.requestAuthentication();

    String action = server.arg(F("action"));
    
    String delete_idx_str = server.arg(F("delete_idx"));
    if (delete_idx_str.length() > 0) {
        int delete_index = delete_idx_str.toInt();
        
        noInterrupts();
        if (delete_index >= 0 && (size_t)delete_index < ignitionMap.size()) {
            ignitionMap.erase(ignitionMap.begin() + delete_index);
            LOG(LOG_INFO, "Kennfeldpunkt %d gel√∂scht.", delete_index);
        }
        interrupts();
        
        server.sendHeader(F("Location"), F("/curve"));
        server.send(303);
        return;
    }

    std::vector<MapPoint> newMap;
    
    for (int i = 0; i < server.args(); i++) {
        String argName = server.argName(i);
        
        if (argName.startsWith(F("rpm_"))) {
            int index = argName.substring(4).toInt();
            String rpmStr = server.arg(argName);
            String tpsStr = server.arg(F("tps_") + String(index));
            String angleStr = server.arg(F("angle_") + String(index));
            
            if (rpmStr.isEmpty() || tpsStr.isEmpty() || angleStr.isEmpty()) {
                if (action != F("add_new") || (size_t)index != ignitionMap.size()) {
                    continue;
                }
            }
            
            if (rpmStr.isEmpty() || tpsStr.isEmpty() || angleStr.isEmpty()) {
                if (action == F("add_new") && (size_t)index == ignitionMap.size()) {
                     server.send(400, F("text/plain"), F("Fehler: Neuer Punkt muss RPM, TPS und Winkel haben."));
                     return;
                }
            }

            int rpm = rpmStr.toInt();
            int tps = tpsStr.toInt();
            int angle = angleStr.toInt();

            if (rpm < 0 || rpm > 15000 || tps < 0 || tps > 1023 || angle < -20 || angle > 30) {
                LOG(LOG_ERROR, "Ung√ºltige Kennfeldwerte (%d RPM, %d TPS, %d Angle).", rpm, tps, angle);
                server.send(400, F("text/plain"), F("Fehler: Ung√ºltige Werte f√ºr RPM/TPS/Winkel."));
                return;
            }

            newMap.push_back({rpm, tps, angle});
        }
    }

    // Kurve √ºbernehmen (in den RAM)
    noInterrupts();
    ignitionMap = newMap;
    interrupts();
    
    // 3. AKTIONEN AUSF√úHREN
    
    if (action == F("save_all")) {
        // AKTION: Speichern auf Flash und Neustart
        LOG(LOG_INFO, "Z√ºndkennfeld in RAM √ºbernommen. Speichere und starte neu.");
        if (saveConfig()) {
            server.send(200, F("text/plain"), F("Kennfeld gespeichert. Neustart..."));
            delay(1000);
            ESP.restart(); 
            return;
        } else {
            server.send(500, F("text/plain"), F("Fehler beim Speichern der Konfiguration."));
            return;
        }
    } 
    
    // apply_only oder Fallback: Auto-Refresh zur Konfigurationsseite
    String responseHtml = F("<html><head><meta http-equiv='refresh' content='2;url=/curve'></head><body><h1>Erfolg!</h1><p>Konfiguration im RAM angewendet. Seite wird in 2 Sekunden neu geladen.</p><p><a href='/curve'>Manuell fortfahren</a></p></body></html>");
    server.send(200, "text/html; charset=utf-8", responseHtml);
}

void handleRestoreCurve() {
    if (!isAuthorized()) return server.requestAuthentication();

    LOG(LOG_WARN, "Wiederherstellung des Standard-Z√ºndkennfelds angefordert.");

    if (loadDataFromJson(FALLBACK_CURVE_JSON)) {
        if (saveConfig()) {
            server.send(200, F("text/plain"), F("Standard-Kennfeld erfolgreich wiederhergestellt. Neustart..."));
            delay(1000);
            ESP.restart();
            return;
        }
    }
    
    server.send(500, F("text/plain"), F("Fehler: Konnte Standard-Kennfeld nicht speichern."));
}

void handleRpmConfig() {
    if (!isAuthorized()) return server.requestAuthentication();

    String html = F("<html><head><meta charset='UTF-8'></head><body><h1>RPM & Z√ºndungs-Timing Konfiguration</h1>");
    html += F("<form method='post' action='/saverpmconfig'>");
    
    // --- 1. RPM Sensor / Timing (Trigger Wheel) ---
    html += F("<h2>1. RPM Sensor / Timing (Trigger Wheel)</h2>");
    html += F("<p><b>Pin:</b> D1 (fest verdrahtet)</p>");
    html += F("Impulse pro Umdrehung: <input type='number' name='pulses' min='1' max='20' value='");
    html += String(rpmConfig.pulses_per_revolution); html += F("' required><br>");
    html += F("Sensor Typ: <select name='is_digital'><option value='1' "); html += rpmConfig.is_digital ? F("selected") : F(""); html += F(">Digital</option><option value='0' "); html += !rpmConfig.is_digital ? F("selected") : F(""); html += F(">Analog</option></select><br><br>");
    
    // --- 2. Statische Z√ºndungs-Justierung (Mechanik) ---
    html += F("<h2>2. Statische Z√ºndungs-Justierung (Mechanik)</h2>");
    html += F("Trigger Offset (&deg; v.OT): <input type='number' name='offset' min='0' max='360' value='");
    html += String(timingConfig.trigger_offset_deg); html += F("' required><br>");
    html += F("TDC Feinjustierung (&deg;): <input type='number' name='tdc' step='0.1' value='");
    html += String(timingConfig.TDC_adjust_deg, 1); html += F("' required><br><br>");

    // --- 3. Z√ºndspule (Elektrische Kalibrierung) ---
    html += F("<h2>3. Z√ºndspule (Elektrische Kalibrierung)</h2>");
    html += F("Prim√§rwiderstand Spule (Rp in &Omega;): <input type='number' name='rp' step='0.1' value='");
    html += String(coilConfig.primary_resistance_ohm, 1); html += F("' min='0.1' required><br>");
    html += F("Externer Vorwiderstand (Rext in &Omega;): <input type='number' name='rext' step='0.1' value='");
    html += String(coilConfig.external_resistance_ohm, 1); html += F("' min='0.0' required><br>");
    html += F("Prim√§rinduktivit√§t (Lp in mH): <input type='number' name='lp' step='0.1' value='");
    html += String(coilConfig.primary_inductance_mH, 1); html += F("' min='0.1' required><br>");
    html += F("Ziel-Prim√§rstrom (I_target in A): <input type='number' name='itarget' step='0.1' value='");
    html += String(coilConfig.target_current_A, 1); html += F("' min='1.0' required><br>");
    html += F("Statische Dwell-Zeit (Fallback in ms): <input type='number' name='dwell' step='0.1' value='");
    html += String(coilConfig.fixed_dwell_ms, 1); html += F("' min='1.0' required><br><br>");
    
    // Aktionen
    html += F("<button type='submit' name='action' value='apply_only' style='background: #ffcc00;'>üß™ Im RAM Anwenden (Test)</button> ");
    html += F("<button type='submit' name='action' value='save_all'>‚úÖ Speichern auf Flash & Neustart</button>");
    
    html += F("</form><p><a href='/'>Zur√ºck</a></p></body></html>");
    server.send(200, "text/html; charset=utf-8", html);
}

void handleSaveRpmConfig() {
    if (!isAuthorized()) return server.requestAuthentication();

    String action = server.arg(F("action"));
    
    // Daten auslesen und validieren
    int pulses = server.arg(F("pulses")).toInt();
    int offset = server.arg(F("offset")).toInt();
    float tdc = server.arg(F("tdc")).toFloat();
    bool is_digital = server.arg(F("is_digital")).toInt() == 1;

    // Spulendaten auslesen
    float rp = server.arg(F("rp")).toFloat();
    float rext = server.arg(F("rext")).toFloat();
    float lp = server.arg(F("lp")).toFloat();
    float itarget = server.arg(F("itarget")).toFloat();
    float dwell = server.arg(F("dwell")).toFloat();


    if (pulses <= 0 || pulses > 20 || offset < 0 || offset > 360 || rp <= 0 || lp <= 0 || itarget <= 0 || dwell <= 0) {
         server.send(400, "text/plain", F("Fehler: Ung√ºltige Werte f√ºr RPM/Timing oder Spulenparameter."));
         return;
    }

    // On-the-Fly Update der globalen VOLATILE Variablen
    noInterrupts();
    rpmConfig.pulses_per_revolution = pulses;
    rpmConfig.is_digital = is_digital;
    timingConfig.trigger_offset_deg = offset;
    timingConfig.TDC_adjust_deg = tdc;

    // Z√ºndspulen Configs aktualisieren
    coilConfig.primary_resistance_ohm = rp;
    coilConfig.external_resistance_ohm = rext;
    coilConfig.primary_inductance_mH = lp;
    coilConfig.target_current_A = itarget;
    coilConfig.fixed_dwell_ms = dwell;
    
    interrupts();
    
    LOG(LOG_INFO, "RPM/Timing/Spule Config im RAM aktualisiert. Rp+Rext: %.1f Ohm", rp + rext);

    if (action == F("save_all")) {
        if (saveConfig()) {
            server.send(200, F("text/plain"), F("Konfiguration gespeichert. Neustart..."));
            delay(1000);
            ESP.restart(); 
            return;
        } else {
            server.send(500, F("text/plain"), F("Fehler beim Speichern der Konfiguration."));
            return;
        }
    } 
    
    // apply_only oder Fallback: Auto-Refresh zur Konfigurationsseite
    String responseHtml = F("<html><head><meta http-equiv='refresh' content='2;url=/rpmconfig'></head><body><h1>Erfolg!</h1><p>Konfiguration im RAM angewendet. Seite wird in 2 Sekunden neu geladen.</p><p><a href='/rpmconfig'>Manuell fortfahren</a></p></body></html>");
    server.send(200, "text/html; charset=utf-8", responseHtml);
}

void handleLogConfig() {
    if (!isAuthorized()) return server.requestAuthentication();
    
    String html = F("<html><head><meta charset='UTF-8'></head><body><h1>üéöÔ∏è Log-Level Konfiguration</h1>");
    html += F("<p>Stellen Sie den minimalen Log-Level f√ºr die serielle Ausgabe ein.</p>");
    html += F("<form method='post' action='/savelogconfig'>");
    
    html += F("Aktiver Log-Level: <select name='level' id='logLevelSelect'>");
    html += F("<option value='0'"); if (activeLogLevel == LOG_DEBUG) html += F(" selected"); html += F(">0: DEBUG (Sehr ausf√ºhrlich)</option>");
    html += F("<option value='1'"); if (activeLogLevel == LOG_INFO) html += F(" selected"); html += F(">1: INFO (Normaler Betrieb)</option>");
    html += F("<option value='2'"); if (activeLogLevel == LOG_WARN) html += F(" selected"); html += F(">2: WARN (Warnungen/Auff√§lligkeiten)</option>");
    html += F("<option value='3'"); if (activeLogLevel == LOG_ERROR) html += F(" selected"); html += F(">3: ERROR (Kritische Fehler)</option>");
    html += F("</select><br><br>");
    
    // ZWEI AKTIONEN
    html += F("<button type='submit' name='action' value='apply_only' style='background: #ffcc00; margin-right: 10px;'>üß™ Im RAM anwenden (Live)</button>");
    html += F("<button type='submit' name='action' value='save_all'>‚úÖ Speichern auf Flash & Neustart</button>");
    
    html += F("</form>");
    
    html += F("<p>Aktuelle RAM-Einstellung: "); html += String((int)activeLogLevel); html += F("</p>");
    html += F("<p><a href='/'>Zur√ºck zum Dashboard</a></p></body></html>");
    
    server.send(200, "text/html; charset=utf-8", html);
}

void handleSaveLogConfig() {
    if (!isAuthorized()) return server.requestAuthentication();

    if (!server.hasArg(F("level")) || !server.hasArg(F("action"))) {
        server.send(400, "text/plain", F("Bad Request: Level oder Action fehlt."));
        return;
    }
    
    int newLevel = server.arg(F("level")).toInt();
    String action = server.arg(F("action")); // <-- KORRIGIERT: Zuweisung von 'action'
    
    // Level im RAM sofort aktualisieren
    noInterrupts();
    activeLogLevel = (LogLevel)constrain(newLevel, 0, 3);
    interrupts();
    
    LOG(LOG_INFO, "Log-Level im RAM auf %d angewendet.", (int)activeLogLevel);

    if (action == F("save_all")) {
        // AKTION 1: SPEICHERN UND NEUSTART
        if (saveConfig()) {
            server.send(200, F("text/plain"), F("Log-Level gespeichert. Neustart..."));
            delay(1000);
            ESP.restart();
            return;
        } else {
            LOG(LOG_ERROR, "Speichern der Config nach Log-Level-√Ñnderung fehlgeschlagen.");
            server.send(500, F("text/plain"), F("Fehler beim Speichern."));
            return;
        }
    }
    
    // AKTION 2: LIVE ANWENDEN (apply_only) oder Fallback
    String responseHtml = F("<html><head><meta http-equiv='refresh' content='2;url=/logconfig'></head><body><h1>Erfolg!</h1><p>Log-Level im RAM angewendet. Serielle Ausgabe sollte sich sofort √§ndern.</p><p><a href='/logconfig'>Manuell fortfahren</a></p></body></html>");
    server.send(200, "text/html; charset=utf-8", responseHtml);
}


void setup_server_routes() {
    server.on(F("/"), handleRoot);
    server.on(F("/set"), handleSetAktor); 
    server.on(F("/config"), handleConfig); 
    server.on(F("/saveconfig"), handleSaveConfig); 
    server.on(F("/viewlog"), handleViewLog); 
    server.on(F("/clearlog"), handleClearLog); 
    server.on(F("/curve"), handleCurveConfig);
    server.on(F("/savecurve"), handleSaveCurve); 
    server.on(F("/restorecurve"), handleRestoreCurve); 
    server.on(F("/rpmconfig"), handleRpmConfig);
    server.on(F("/saverpmconfig"), handleSaveRpmConfig);
    server.on(F("/logconfig"), handleLogConfig);    
    server.on(F("/savelogconfig"), handleSaveLogConfig); 
    server.begin();
    serverStarted = true; // WICHTIG: Webserver ist jetzt aktiv, Pufferung stoppen.
    LOG(LOG_INFO, "HTTP Routen konfiguriert und Server gestartet.");
}

void setup_ota() {
  if (WiFi.status() != WL_CONNECTED) { return; }
  MDNS.begin(apSsid.c_str());
  ArduinoOTA.setHostname(apSsid.c_str());
  ArduinoOTA.setPassword(apPassword.c_str());
  
  ArduinoOTA.onStart([]() { server.stop(); LOG(LOG_WARN, "OTA Update beginnt."); });
  ArduinoOTA.onEnd([]() { LOG(LOG_INFO, "OTA Update erfolgreich. Neustart."); });
  ArduinoOTA.onError([](ota_error_t error) { LOG(LOG_ERROR, "OTA Fehler: Code %d", error); }); 
  
  ArduinoOTA.begin();
  LOG(LOG_INFO, "OTA Service gestartet.");
}


// =========================================================
// 7. SETUP und LOOP
// =========================================================

void setup() {
  Serial.begin(115200); 
  delay(100);

  Serial.println(F("\n--- SYSTEM START: Logger Test (115200 Baud) ---")); 
  LOG(LOG_INFO, "Serielle Kommunikation initialisiert.");
  
  // 1. Z√ºndungs-Core initialisieren
  pinMode(IGNITION_INPUT_PIN, INPUT_PULLUP);
  pinMode(IGNITION_OUTPUT_PIN, OUTPUT);
  pinMode(SPEED_INPUT_PIN, INPUT_PULLUP); 
  digitalWrite(IGNITION_OUTPUT_PIN, LOW);

  timer1_disable(); 
  attachInterrupt(digitalPinToInterrupt(IGNITION_INPUT_PIN), handleIgnitionPulse, RISING);
  attachInterrupt(digitalPinToInterrupt(SPEED_INPUT_PIN), handleSpeedPulse, RISING); 

  // 2. Initialisiere die schnellen, polymorphen Sensor-Tasks 
  allSensorTasks.push_back({std::make_unique<TPS_Sensor>(ADC_PIN, 50), 0, SID_TPS_RAW});
  allSensorTasks.push_back({std::make_unique<Static_Sensor>(0.0f, 50), 0, SID_SPEED}); 
  allSensorTasks.push_back({std::make_unique<CalibratedAnalog_Sensor>(3.3f, 11.0f, 1000), 0, SID_BATT_V});
  allSensorTasks.push_back({std::make_unique<TempSensorSim>(1000), 0, SID_TEMP_KOPF}); 

  // 3. Konfiguration und WLAN
  if (!LittleFS.begin()) { LOG(LOG_WARN, "LittleFS formatiert."); LittleFS.format(); }
  if (!loadConfig()) loadDataFromJson(FALLBACK_CURVE_JSON); 

  // NEU: Zus√§tzliches Debugging VOR dem WiFi.begin()
  LOG(LOG_INFO, "WLAN Setup: Verbinde mit '%s' (PW-L√§nge: %d)", wifiSsid.c_str(), wifiPassword.length());

  WiFi.mode(WIFI_STA);
  WiFi.begin(wifiSsid.c_str(), wifiPassword.c_str()); 
  LOG(LOG_INFO, "Versuche, mit %s zu verbinden...", wifiSsid.c_str());

  unsigned long startTime = millis();
  const unsigned long TIMEOUT = 15000;
  while (WiFi.status() != WL_CONNECTED && (millis() - startTime < TIMEOUT)) {
      delay(100); ESP.wdtFeed(); 
  }

  if (WiFi.status() == WL_CONNECTED) {
      LOG(LOG_INFO, "‚úÖ Verbunden! IP: %s", WiFi.localIP().toString().c_str());
      boot_time_ms = millis();
      setup_server_routes(); 
      server.begin();
      setup_ota(); 
      advanceTicker.attach_ms(50, updateIgnitionParameters); 
      debugTicker.attach(1, printLoopStatus); 
      LOG(LOG_INFO, "System bereit. Heap: %d Bytes", ESP.getFreeHeap());
  } else {
      LOG(LOG_WARN, "Verbindung fehlgeschlagen. Starte AP-Modus.");
      startApMode = true;
      setup_server_routes();
  }
}

void loop() {
    ESP.wdtFeed();

    unsigned long start_loop_micros = micros();
    unsigned long now = millis();

    // 1. AP/STA Modus Handling
    if (startApMode) {
        if (WiFi.getMode() != WIFI_AP) {
            WiFi.mode(WIFI_AP);
            WiFi.softAP(apSsid.c_str(), apPassword.c_str()); 
            LOG(LOG_INFO, "AP IP: %s", WiFi.softAPIP().toString().c_str());
        }
        server.handleClient();
    } else { 
        if (now - lastWebHandle >= WEB_HANDLE_INTERVAL) {
            server.handleClient();
            lastWebHandle = now;
        }
        if (now - lastOtaHandle >= OTA_HANDLE_INTERVAL) {
            ArduinoOTA.handle();
            lastOtaHandle = now;
        }
    }
    
    // 2. Heap Check und Statistik-Aktualisierung
    if (now - lastHeapCheck >= HEAP_CHECK_INTERVAL) {
        checkHeapHealth();
        lastHeapCheck = now;
    }

    // Loop-Dauer messen und Statistik aktualisieren
    unsigned long current_duration = micros() - start_loop_micros;
    loop_durations_buffer[stats_index] = current_duration;
    stats_index = (stats_index + 1) % STATS_WINDOW_SIZE;
    
    if (++calc_counter >= CALC_FREQUENCY) {
        calculateLoopStatistics();
        calc_counter = 0;
    }
}